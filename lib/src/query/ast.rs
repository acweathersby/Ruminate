
/* **** DO NOT MODIFY **** DO NOT MODIFY **** DO NOT MODIFY ****
 * 
 * This code has been automatically generated by Hydrocarbon Toolkit
 * 
 * ###################################################################
 * 
 * Copyright 2022 Anthony C. Weathersby
 * 
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 */


use std::cell::UnsafeCell;

use hctk::ast::{HCObj, HCObjTrait, ReduceFunction};

use hctk::Token;

type RF = ReduceFunction<ASTNode>;

type HCO = HCObj<ASTNode>;


#[derive(Debug, Clone)]
pub enum ASTNode {NONE,QueryBody(Box<QueryBody>),
ContainerClause(Box<ContainerClause>),
AND(Box<AND>),
OR(Box<OR>),
NOT(Box<NOT>),
MATCH(Box<MATCH>),
CREATED(Box<CREATED>),
MODIFIED(Box<MODIFIED>),
SIZE(Box<SIZE>),
TAG(Box<TAG>),
EQUALS_QUANTITATIVE(Box<EQUALS_QUANTITATIVE>),
EQUALS_QUALITATIVE(Box<EQUALS_QUALITATIVE>),
GREATERTHAN(Box<GREATERTHAN>),
LESSTHAN(Box<LESSTHAN>),
RANGE(Box<RANGE>),
DATE(Box<DATE>),
ORDER(Box<ORDER>),
IDENTIFIERS(Box<IDENTIFIERS>) 
}
    
impl HCObjTrait for ASTNode {
    fn String(&self) -> String {
        use ASTNode::*;
        match self {
            
            QueryBody(bx) => bx.tok.String(),

            ContainerClause(bx) => bx.tok.String(),

            AND(bx) => bx.tok.String(),

            OR(bx) => bx.tok.String(),

            NOT(bx) => bx.tok.String(),

            MATCH(bx) => bx.tok.String(),

            CREATED(bx) => bx.tok.String(),

            MODIFIED(bx) => bx.tok.String(),

            SIZE(bx) => bx.tok.String(),

            TAG(bx) => bx.tok.String(),

            EQUALS_QUANTITATIVE(bx) => bx.tok.String(),

            EQUALS_QUALITATIVE(bx) => bx.tok.String(),

            GREATERTHAN(bx) => bx.tok.String(),

            LESSTHAN(bx) => bx.tok.String(),

            RANGE(bx) => bx.tok.String(),

            DATE(bx) => bx.tok.String(),

            ORDER(bx) => bx.tok.String(),

            IDENTIFIERS(bx) => bx.tok.String(),
            _ => String::from(""),
        }
    }
}



#[derive(Debug)]
pub enum NodeIteration<'a> {
    NONE,
    STOP,
    CONTINUE,
    REPLACE(ASTNode),
    QueryBody(&'a mut QueryBody),
ContainerClause(&'a mut ContainerClause),
AND(&'a mut AND),
OR(&'a mut OR),
NOT(&'a mut NOT),
MATCH(&'a mut MATCH),
CREATED(&'a mut CREATED),
MODIFIED(&'a mut MODIFIED),
SIZE(&'a mut SIZE),
TAG(&'a mut TAG),
EQUALS_QUANTITATIVE(&'a mut EQUALS_QUANTITATIVE),
EQUALS_QUALITATIVE(&'a mut EQUALS_QUALITATIVE),
GREATERTHAN(&'a mut GREATERTHAN),
LESSTHAN(&'a mut LESSTHAN),
RANGE(&'a mut RANGE),
DATE(&'a mut DATE),
ORDER(&'a mut ORDER),
IDENTIFIERS(&'a mut IDENTIFIERS)
}

impl<'a> NodeIteration<'a> {
    pub fn name(&self) -> &str {
        use NodeIteration::*;
        match self {
            STOP => "stop",
            
                QueryBody(_0) => {
                    "node-QueryBody"
                },
                ContainerClause(_0) => {
                    "node-ContainerClause"
                },
                AND(_0) => {
                    "node-AND"
                },
                OR(_0) => {
                    "node-OR"
                },
                NOT(_0) => {
                    "node-NOT"
                },
                MATCH(_0) => {
                    "node-MATCH"
                },
                CREATED(_0) => {
                    "node-CREATED"
                },
                MODIFIED(_0) => {
                    "node-MODIFIED"
                },
                SIZE(_0) => {
                    "node-SIZE"
                },
                TAG(_0) => {
                    "node-TAG"
                },
                EQUALS_QUANTITATIVE(_0) => {
                    "node-EQUALS_QUANTITATIVE"
                },
                EQUALS_QUALITATIVE(_0) => {
                    "node-EQUALS_QUALITATIVE"
                },
                GREATERTHAN(_0) => {
                    "node-GREATERTHAN"
                },
                LESSTHAN(_0) => {
                    "node-LESSTHAN"
                },
                RANGE(_0) => {
                    "node-RANGE"
                },
                DATE(_0) => {
                    "node-DATE"
                },
                ORDER(_0) => {
                    "node-ORDER"
                },
                IDENTIFIERS(_0) => {
                    "node-IDENTIFIERS"
                }
            REPLACE(node) => "replace",
            _ => "unknown",
        }
    }
}

pub trait ASTNodeTraits<'a>
where
    Self: Sized,
{
    fn iterate(
        self: &'a mut Box<Self>,
        _yield: &'a mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>) -> NodeIteration<'a>,
    ) {
        let mut closure = |a: &mut NodeIteration<'a>, b: &mut NodeIteration<'a>, ty:u32, c: i32, d: i32| {
            use NodeIteration::*;
            match _yield(a, b) {
                STOP => false,
                REPLACE(node) => match b {
                    
                    QueryBody(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    ContainerClause(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    AND(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    OR(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    NOT(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    MATCH(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    CREATED(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    MODIFIED(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    SIZE(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    TAG(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    EQUALS_QUANTITATIVE(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    EQUALS_QUALITATIVE(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    GREATERTHAN(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    LESSTHAN(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    RANGE(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    DATE(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    ORDER(par) => {
                        par.Replace(node, c, d);
                        true
                    },
                    IDENTIFIERS(par) => {
                        par.Replace(node, c, d);
                        true
                    }
                    _ => true,
                },
                _ => true,
            }
        };

        self.Iterate(&mut closure, &mut NodeIteration::NONE, 0, 0)
    }
    fn Replace(&mut self, node: ASTNode, i: i32, j: i32) -> ASTNode {
        ASTNode::NONE
    }
    fn Iterate(
        self: &'a mut Box<Self>,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    );
    fn Token(&self) -> Token;
    fn Type() -> u32;
    fn GetType(&self) -> u32;
}




#[derive(Debug, Clone)]
pub struct QueryBody {
    pub tok:Token,
    pub container:Box<ContainerClause>,
pub filter:ASTNode,
pub sort:any
}

impl QueryBody {
fn new( tok: Token, _container:Box<ContainerClause>, _filter:ASTNode, _sort:any) -> Box<Self> {
    Box::new(QueryBody{
        tok: tok,
        container : _container,
        filter : _filter,
        sort : _sort,
    })
}


fn  replace_container(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.container.is_some() {
                let old = std::mem::replace(&mut self.container, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::ContainerClause(old_node));
                }
            }
        }

        ASTNode::ContainerClause(child) => {
            if self.container.is_none() {
                self.container = Some(child);
            } else {
                let old = std::mem::replace(&mut self.container, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::ContainerClause(old_node));
                }
            }
        }
        _ => {}
    }
    None
}

fn  replace_filter(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.filter, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::AND(_) => { 
            return Some(std::mem::replace(&mut self.filter, child));
        },

        ASTNode::OR(_) => { 
            return Some(std::mem::replace(&mut self.filter, child));
        },

        ASTNode::NOT(_) => { 
            return Some(std::mem::replace(&mut self.filter, child));
        },

        ASTNode::MATCH(_) => { 
            return Some(std::mem::replace(&mut self.filter, child));
        },

        ASTNode::CREATED(_) => { 
            return Some(std::mem::replace(&mut self.filter, child));
        },

        ASTNode::MODIFIED(_) => { 
            return Some(std::mem::replace(&mut self.filter, child));
        },

        ASTNode::SIZE(_) => { 
            return Some(std::mem::replace(&mut self.filter, child));
        },

        ASTNode::TAG(_) => { 
            return Some(std::mem::replace(&mut self.filter, child));
        }
        _ => None
        
    }
}

fn  replace_sort(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::CREATED(_)|ASTNode::MODIFIED(_)|ASTNode::SIZE(_)|ASTNode::TAG(_) => {
            if index as usize >= self.sort.len() {
                self.sort.push(child);
                None
            }else {
                self.sort.push(child);
                let node = self.sort.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.sort.len() {
                let node = self.sort.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}
}



impl<'a> ASTNodeTraits<'a> for QueryBody
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::QueryBody(mut_me), parent, 22, i, j) { return };
    }
        
    
        {
            if let Some(child) = &mut (unsafe { (*node.get()).as_mut() }.container) {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                child.Iterate(_yield, &mut NodeIteration::QueryBody(mut_me_b), 0, 0);
            }
        }
    
        {
            if let Some(child) = &mut (unsafe { (*node.get()).as_mut() }.filter) {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                child.Iterate(_yield, &mut NodeIteration::QueryBody(mut_me_b), 1, 0);
            }
        }
    
        {

            let mut_me_a = unsafe { (*node.get()).as_mut() };
            for j in 0..mut_me_a.sort.len() {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                let child = &mut mut_me_b.sort[j];

                match child {
                    
                        ASTNode::CREATED(child) => { 
                            let mut_me = unsafe { (*node.get()).as_mut() };
                            child.Iterate(_yield, &mut NodeIteration::QueryBody(mut_me), 2, j as i32)   
                        },

                        ASTNode::MODIFIED(child) => { 
                            let mut_me = unsafe { (*node.get()).as_mut() };
                            child.Iterate(_yield, &mut NodeIteration::QueryBody(mut_me), 2, j as i32)   
                        },

                        ASTNode::SIZE(child) => { 
                            let mut_me = unsafe { (*node.get()).as_mut() };
                            child.Iterate(_yield, &mut NodeIteration::QueryBody(mut_me), 2, j as i32)   
                        },

                        ASTNode::TAG(child) => { 
                            let mut_me = unsafe { (*node.get()).as_mut() };
                            child.Iterate(_yield, &mut NodeIteration::QueryBody(mut_me), 2, j as i32)   
                        }
                    _ => {}
                }
            }
        }
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_container(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_filter(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    2 => {
                    
        if let Some(old) = self.replace_sort(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 22;
}

fn GetType(&self) -> u32 {
    return 22;
}
}




#[derive(Debug, Clone)]
pub struct ContainerClause {
    pub tok:Token,
    pub path:Vec<Box<IDENTIFIERS>>,
pub container:Box<IDENTIFIERS>
}

impl ContainerClause {
fn new( tok: Token, _path:Vec<Box<IDENTIFIERS>>, _container:Box<IDENTIFIERS>) -> Box<Self> {
    Box::new(ContainerClause{
        tok: tok,
        path : _path,
        container : _container,
    })
}


fn  replace_path(&mut self, child: ASTNode,index: i32,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::IDENTIFIERS(_) => {
            if index as usize >= self.path.len() {
                self.path.push(child);
                None
            }else {
                self.path.push(child);
                let node = self.path.swap_remove(index as usize);
                Some(node)
            }
        }
        ASTNode::NONE => {
            if (index as usize)< self.path.len() {
                let node = self.path.remove(index as usize);
                Some(node)
            }else {
                None
            }
        }
        _ => None
    }
}

fn  replace_container(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.container.is_some() {
                let old = std::mem::replace(&mut self.container, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::IDENTIFIERS(old_node));
                }
            }
        }

        ASTNode::IDENTIFIERS(child) => {
            if self.container.is_none() {
                self.container = Some(child);
            } else {
                let old = std::mem::replace(&mut self.container, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::IDENTIFIERS(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for ContainerClause
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::ContainerClause(mut_me), parent, 24, i, j) { return };
    }
        
    
        {

            let mut_me_a = unsafe { (*node.get()).as_mut() };
            for j in 0..mut_me_a.path.len() {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                let child = &mut mut_me_b.path[j];

                
                if let ASTNode::IDENTIFIERS(child) = child {
                    let mut_me = unsafe { (*node.get()).as_mut() };
                    child.Iterate( _yield, &mut NodeIteration::ContainerClause(mut_me), 0, j as i32);
                }
            }
        }
    
        {
            if let Some(child) = &mut (unsafe { (*node.get()).as_mut() }.container) {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                child.Iterate(_yield, &mut NodeIteration::ContainerClause(mut_me_b), 1, 0);
            }
        }
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_path(child, j){ 
            return old;
        }else{
            return ASTNode::NONE;
        }
                }
    1 => {
                    
        if let Some(old) = self.replace_container(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 24;
}

fn GetType(&self) -> u32 {
    return 24;
}
}




#[derive(Debug, Clone)]
pub struct AND {
    pub tok:Token,
    pub left:ASTNode,
pub right:ASTNode
}

impl AND {
fn new( tok: Token, _left:ASTNode, _right:ASTNode) -> Box<Self> {
    Box::new(AND{
        tok: tok,
        left : _left,
        right : _right,
    })
}


fn  replace_left(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.left, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::OR(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::NOT(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::MATCH(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::CREATED(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::MODIFIED(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::SIZE(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::TAG(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        }
        _ => None
        
    }
}

fn  replace_right(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.right, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::AND(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::OR(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::NOT(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::MATCH(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::CREATED(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::MODIFIED(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::SIZE(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::TAG(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for AND
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::AND(mut_me), parent, 26, i, j) { return };
    }
        
    
        {
            let mut_me_b = unsafe { (*node.get()).as_mut() };
            (unsafe { (*node.get()).as_mut() }.left).Iterate( _yield, &mut NodeIteration::AND(mut_me_b), 0, 0);
            
        }
    
        {
            let mut_me_b = unsafe { (*node.get()).as_mut() };
            (unsafe { (*node.get()).as_mut() }.right).Iterate( _yield, &mut NodeIteration::AND(mut_me_b), 1, 0);
            
        }
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_left(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_right(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 26;
}

fn GetType(&self) -> u32 {
    return 26;
}
}




#[derive(Debug, Clone)]
pub struct OR {
    pub tok:Token,
    pub left:ASTNode,
pub right:ASTNode
}

impl OR {
fn new( tok: Token, _left:ASTNode, _right:ASTNode) -> Box<Self> {
    Box::new(OR{
        tok: tok,
        left : _left,
        right : _right,
    })
}


fn  replace_left(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.left, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::NOT(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::MATCH(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::CREATED(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::MODIFIED(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::SIZE(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::TAG(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        }
        _ => None
        
    }
}

fn  replace_right(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.right, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::OR(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::NOT(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::MATCH(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::CREATED(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::MODIFIED(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::SIZE(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        },

        ASTNode::TAG(_) => { 
            return Some(std::mem::replace(&mut self.right, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for OR
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::OR(mut_me), parent, 28, i, j) { return };
    }
        
    
        {
            let mut_me_b = unsafe { (*node.get()).as_mut() };
            (unsafe { (*node.get()).as_mut() }.left).Iterate( _yield, &mut NodeIteration::OR(mut_me_b), 0, 0);
            
        }
    
        {
            let mut_me_b = unsafe { (*node.get()).as_mut() };
            (unsafe { (*node.get()).as_mut() }.right).Iterate( _yield, &mut NodeIteration::OR(mut_me_b), 1, 0);
            
        }
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_left(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_right(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 28;
}

fn GetType(&self) -> u32 {
    return 28;
}
}




#[derive(Debug, Clone)]
pub struct NOT {
    pub tok:Token,
    pub left:ASTNode
}

impl NOT {
fn new( tok: Token, _left:ASTNode) -> Box<Self> {
    Box::new(NOT{
        tok: tok,
        left : _left,
    })
}


fn  replace_left(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.left, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::MATCH(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::CREATED(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::MODIFIED(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::SIZE(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        },

        ASTNode::TAG(_) => { 
            return Some(std::mem::replace(&mut self.left, child));
        }
        _ => None
        
    }
}
}



impl<'a> ASTNodeTraits<'a> for NOT
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::NOT(mut_me), parent, 30, i, j) { return };
    }
        
    
        {
            let mut_me_b = unsafe { (*node.get()).as_mut() };
            (unsafe { (*node.get()).as_mut() }.left).Iterate( _yield, &mut NodeIteration::NOT(mut_me_b), 0, 0);
            
        }
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_left(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 30;
}

fn GetType(&self) -> u32 {
    return 30;
}
}




#[derive(Debug, Clone)]
pub struct MATCH {
    pub tok:Token,
    pub value:Token
}

impl MATCH {
fn new( tok: Token, _value:Token) -> Box<Self> {
    Box::new(MATCH{
        tok: tok,
        value : _value,
    })
}


}



impl<'a> ASTNodeTraits<'a> for MATCH
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::MATCH(mut_me), parent, 32, i, j) { return };
    }
        
    
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 32;
}

fn GetType(&self) -> u32 {
    return 32;
}
}




#[derive(Debug, Clone)]
pub struct CREATED {
    pub tok:Token,
    pub val:ASTNode,
pub order:Box<ORDER>
}

impl CREATED {
fn new( tok: Token, _val:ASTNode, _order:Box<ORDER>) -> Box<Self> {
    Box::new(CREATED{
        tok: tok,
        val : _val,
        order : _order,
    })
}


fn  replace_val(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.val, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::EQUALS_QUANTITATIVE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::EQUALS_QUALITATIVE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::GREATERTHAN(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::LESSTHAN(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::RANGE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::DATE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        }
        _ => None
        
    }
}

fn  replace_order(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.order.is_some() {
                let old = std::mem::replace(&mut self.order, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::ORDER(old_node));
                }
            }
        }

        ASTNode::ORDER(child) => {
            if self.order.is_none() {
                self.order = Some(child);
            } else {
                let old = std::mem::replace(&mut self.order, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::ORDER(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for CREATED
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::CREATED(mut_me), parent, 34, i, j) { return };
    }
        
    
        {
            if let Some(child) = &mut (unsafe { (*node.get()).as_mut() }.val) {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                child.Iterate(_yield, &mut NodeIteration::CREATED(mut_me_b), 0, 0);
            }
        }
    
        {
            if let Some(child) = &mut (unsafe { (*node.get()).as_mut() }.order) {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                child.Iterate(_yield, &mut NodeIteration::CREATED(mut_me_b), 1, 0);
            }
        }
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_val(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_order(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 34;
}

fn GetType(&self) -> u32 {
    return 34;
}
}




#[derive(Debug, Clone)]
pub struct MODIFIED {
    pub tok:Token,
    pub val:ASTNode,
pub order:Box<ORDER>
}

impl MODIFIED {
fn new( tok: Token, _val:ASTNode, _order:Box<ORDER>) -> Box<Self> {
    Box::new(MODIFIED{
        tok: tok,
        val : _val,
        order : _order,
    })
}


fn  replace_val(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.val, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::EQUALS_QUANTITATIVE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::EQUALS_QUALITATIVE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::GREATERTHAN(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::LESSTHAN(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::RANGE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::DATE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        }
        _ => None
        
    }
}

fn  replace_order(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.order.is_some() {
                let old = std::mem::replace(&mut self.order, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::ORDER(old_node));
                }
            }
        }

        ASTNode::ORDER(child) => {
            if self.order.is_none() {
                self.order = Some(child);
            } else {
                let old = std::mem::replace(&mut self.order, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::ORDER(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for MODIFIED
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::MODIFIED(mut_me), parent, 36, i, j) { return };
    }
        
    
        {
            if let Some(child) = &mut (unsafe { (*node.get()).as_mut() }.val) {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                child.Iterate(_yield, &mut NodeIteration::MODIFIED(mut_me_b), 0, 0);
            }
        }
    
        {
            if let Some(child) = &mut (unsafe { (*node.get()).as_mut() }.order) {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                child.Iterate(_yield, &mut NodeIteration::MODIFIED(mut_me_b), 1, 0);
            }
        }
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_val(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_order(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 36;
}

fn GetType(&self) -> u32 {
    return 36;
}
}




#[derive(Debug, Clone)]
pub struct SIZE {
    pub tok:Token,
    pub val:ASTNode,
pub order:Box<ORDER>
}

impl SIZE {
fn new( tok: Token, _val:ASTNode, _order:Box<ORDER>) -> Box<Self> {
    Box::new(SIZE{
        tok: tok,
        val : _val,
        order : _order,
    })
}


fn  replace_val(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.val, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::EQUALS_QUANTITATIVE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::EQUALS_QUALITATIVE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::GREATERTHAN(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::LESSTHAN(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::RANGE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::DATE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        }
        _ => None
        
    }
}

fn  replace_order(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.order.is_some() {
                let old = std::mem::replace(&mut self.order, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::ORDER(old_node));
                }
            }
        }

        ASTNode::ORDER(child) => {
            if self.order.is_none() {
                self.order = Some(child);
            } else {
                let old = std::mem::replace(&mut self.order, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::ORDER(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for SIZE
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::SIZE(mut_me), parent, 38, i, j) { return };
    }
        
    
        {
            let mut_me_b = unsafe { (*node.get()).as_mut() };
            (unsafe { (*node.get()).as_mut() }.val).Iterate( _yield, &mut NodeIteration::SIZE(mut_me_b), 0, 0);
            
        }
    
        {
            if let Some(child) = &mut (unsafe { (*node.get()).as_mut() }.order) {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                child.Iterate(_yield, &mut NodeIteration::SIZE(mut_me_b), 1, 0);
            }
        }
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_val(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_order(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 38;
}

fn GetType(&self) -> u32 {
    return 38;
}
}




#[derive(Debug, Clone)]
pub struct TAG {
    pub tok:Token,
    pub id:Box<IDENTIFIERS>,
pub val:ASTNode,
pub order:Box<ORDER>
}

impl TAG {
fn new( tok: Token, _id:Box<IDENTIFIERS>, _val:ASTNode, _order:Box<ORDER>) -> Box<Self> {
    Box::new(TAG{
        tok: tok,
        id : _id,
        val : _val,
        order : _order,
    })
}


fn  replace_id(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    if let ASTNode::IDENTIFIERS(child) = child {
        return Some(ASTNode::IDENTIFIERS(std::mem::replace(&mut self.id, child)))
    }else {
        return None
    }
    
}

fn  replace_val(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match &child {
        ASTNode::NONE => {
            let old = std::mem::replace(&mut self.val, ASTNode::NONE);
            return Some(old);
        }
        
        ASTNode::EQUALS_QUANTITATIVE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::EQUALS_QUALITATIVE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::GREATERTHAN(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::LESSTHAN(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::RANGE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        },

        ASTNode::DATE(_) => { 
            return Some(std::mem::replace(&mut self.val, child));
        }
        _ => None
        
    }
}

fn  replace_order(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    match child {
        ASTNode::NONE => {
            if self.order.is_some() {
                let old = std::mem::replace(&mut self.order, None);
                if let Some(old_node) = old {
                    return Some(ASTNode::ORDER(old_node));
                }
            }
        }

        ASTNode::ORDER(child) => {
            if self.order.is_none() {
                self.order = Some(child);
            } else {
                let old = std::mem::replace(&mut self.order, Some(child));

                if let Some(old_node) = old {
                    return Some(ASTNode::ORDER(old_node));
                }
            }
        }
        _ => {}
    }
    None
}
}



impl<'a> ASTNodeTraits<'a> for TAG
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::TAG(mut_me), parent, 40, i, j) { return };
    }
        
    
        {
            let mut_me_b = unsafe { (*node.get()).as_mut() };
            (unsafe { (*node.get()).as_mut() }.id).Iterate( _yield, &mut NodeIteration::TAG(mut_me_b), 0, 0);
            
        }
    
        {
            if let Some(child) = &mut (unsafe { (*node.get()).as_mut() }.val) {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                child.Iterate(_yield, &mut NodeIteration::TAG(mut_me_b), 1, 0);
            }
        }
    
        {
            if let Some(child) = &mut (unsafe { (*node.get()).as_mut() }.order) {
                let mut_me_b = unsafe { (*node.get()).as_mut() };
                child.Iterate(_yield, &mut NodeIteration::TAG(mut_me_b), 2, 0);
            }
        }
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_id(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    1 => {
                    
        if let Some(old) = self.replace_val(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
    2 => {
                    
        if let Some(old) = self.replace_order(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 40;
}

fn GetType(&self) -> u32 {
    return 40;
}
}




#[derive(Debug, Clone)]
pub struct EQUALS_QUANTITATIVE {
    pub tok:Token,
    pub val:f64
}

impl EQUALS_QUANTITATIVE {
fn new( tok: Token, _val:f64) -> Box<Self> {
    Box::new(EQUALS_QUANTITATIVE{
        tok: tok,
        val : _val,
    })
}


}



impl<'a> ASTNodeTraits<'a> for EQUALS_QUANTITATIVE
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::EQUALS_QUANTITATIVE(mut_me), parent, 42, i, j) { return };
    }
        
    
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 42;
}

fn GetType(&self) -> u32 {
    return 42;
}
}




#[derive(Debug, Clone)]
pub struct EQUALS_QUALITATIVE {
    pub tok:Token,
    pub val:Box<IDENTIFIERS>
}

impl EQUALS_QUALITATIVE {
fn new( tok: Token, _val:Box<IDENTIFIERS>) -> Box<Self> {
    Box::new(EQUALS_QUALITATIVE{
        tok: tok,
        val : _val,
    })
}


fn  replace_val(&mut self, child: ASTNode,) -> Option<ASTNode> {
    
    if let ASTNode::IDENTIFIERS(child) = child {
        return Some(ASTNode::IDENTIFIERS(std::mem::replace(&mut self.val, child)))
    }else {
        return None
    }
    
}
}



impl<'a> ASTNodeTraits<'a> for EQUALS_QUALITATIVE
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::EQUALS_QUALITATIVE(mut_me), parent, 44, i, j) { return };
    }
        
    
        {
            let mut_me_b = unsafe { (*node.get()).as_mut() };
            (unsafe { (*node.get()).as_mut() }.val).Iterate( _yield, &mut NodeIteration::EQUALS_QUALITATIVE(mut_me_b), 0, 0);
            
        }
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    0 => {
                    
        if let Some(old) = self.replace_val(child){ 
                return old;
            }else{
                return ASTNode::NONE;
            }
                }
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 44;
}

fn GetType(&self) -> u32 {
    return 44;
}
}




#[derive(Debug, Clone)]
pub struct GREATERTHAN {
    pub tok:Token,
    pub val:f64
}

impl GREATERTHAN {
fn new( tok: Token, _val:f64) -> Box<Self> {
    Box::new(GREATERTHAN{
        tok: tok,
        val : _val,
    })
}


}



impl<'a> ASTNodeTraits<'a> for GREATERTHAN
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::GREATERTHAN(mut_me), parent, 46, i, j) { return };
    }
        
    
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 46;
}

fn GetType(&self) -> u32 {
    return 46;
}
}




#[derive(Debug, Clone)]
pub struct LESSTHAN {
    pub tok:Token,
    pub val:f64
}

impl LESSTHAN {
fn new( tok: Token, _val:f64) -> Box<Self> {
    Box::new(LESSTHAN{
        tok: tok,
        val : _val,
    })
}


}



impl<'a> ASTNodeTraits<'a> for LESSTHAN
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::LESSTHAN(mut_me), parent, 48, i, j) { return };
    }
        
    
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 48;
}

fn GetType(&self) -> u32 {
    return 48;
}
}




#[derive(Debug, Clone)]
pub struct RANGE {
    pub tok:Token,
    pub left:f64,
pub right:f64
}

impl RANGE {
fn new( tok: Token, _left:f64, _right:f64) -> Box<Self> {
    Box::new(RANGE{
        tok: tok,
        left : _left,
        right : _right,
    })
}


}



impl<'a> ASTNodeTraits<'a> for RANGE
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::RANGE(mut_me), parent, 50, i, j) { return };
    }
        
    
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 50;
}

fn GetType(&self) -> u32 {
    return 50;
}
}




#[derive(Debug, Clone)]
pub struct DATE {
    pub tok:Token,
    pub from:String,
pub to:String
}

impl DATE {
fn new( tok: Token, _from:String, _to:String) -> Box<Self> {
    Box::new(DATE{
        tok: tok,
        from : _from,
        to : _to,
    })
}


}



impl<'a> ASTNodeTraits<'a> for DATE
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::DATE(mut_me), parent, 52, i, j) { return };
    }
        
    
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 52;
}

fn GetType(&self) -> u32 {
    return 52;
}
}




#[derive(Debug, Clone)]
pub struct ORDER {
    pub tok:Token,
    pub val:f64
}

impl ORDER {
fn new( tok: Token, _val:f64) -> Box<Self> {
    Box::new(ORDER{
        tok: tok,
        val : _val,
    })
}


}



impl<'a> ASTNodeTraits<'a> for ORDER
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::ORDER(mut_me), parent, 54, i, j) { return };
    }
        
    
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 54;
}

fn GetType(&self) -> u32 {
    return 54;
}
}




#[derive(Debug, Clone)]
pub struct IDENTIFIERS {
    pub tok:Token,
    pub ids:Vec<Token>
}

impl IDENTIFIERS {
fn new( tok: Token, _ids:Vec<Token>) -> Box<Self> {
    Box::new(IDENTIFIERS{
        tok: tok,
        ids : _ids,
    })
}


}



impl<'a> ASTNodeTraits<'a> for IDENTIFIERS
where
    Self: Sized,
{

fn Iterate(
    self: &'a mut Box<Self>,
    _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>,u32, i32, i32) -> bool,
    parent: &mut NodeIteration<'a>,
    i: i32,
    j: i32,
) {
    let node = UnsafeCell::from(self);

    {
        let mut_me = unsafe { (*node.get()).as_mut() };

        if !_yield(&mut NodeIteration::IDENTIFIERS(mut_me), parent, 56, i, j) { return };
    }
        
    
    
}

fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode{

    match i{
    
        _ => {}
    };

    ASTNode::NONE
}


fn Token(&self) -> Token{
    return self.tok;
}

fn Type()-> u32{
    return 56;
}

fn GetType(&self) -> u32 {
    return 56;
}
}



fn _fn0 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODE(r_0) = v0 { 
 if let ASTNode::ContainerClause(r_1) = r_0 { 
 if let HCO::NODE(r_2) = v1 { 
 let mut ref_0 = HCO::NODE(ASTNode::QueryBody(QueryBody::new(
        tok,
        Some(r_1),
        r_2,
        v2,
    ) 
));;

                                args.push(ref_0);  } } }
                            }
fn _fn1 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v0 { 
 let mut ref_0 = HCO::NODE(ASTNode::QueryBody(QueryBody::new(
        tok,
        Vec::new(),
        r_0,
        v1,
    ) 
));;

                                args.push(ref_0);  }
                            }
fn _fn2 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v0 { 
 if let ASTNode::ContainerClause(r_1) = r_0 { 
 let mut ref_0 = HCO::NODE(ASTNode::QueryBody(QueryBody::new(
        tok,
        Some(r_1),
        Vec::new(),
        v1,
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn3 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v0 { 
 if let ASTNode::ContainerClause(r_1) = r_0 { 
 if let HCO::NODE(r_2) = v1 { 
 let mut ref_0 = HCO::NODE(ASTNode::QueryBody(QueryBody::new(
        tok,
        Some(r_1),
        r_2,
        __NULL__,
    ) 
));;

                                args.push(ref_0);  } } }
                            }
fn _fn4 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 let mut ref_0 = HCO::NODE(ASTNode::QueryBody(QueryBody::new(
        tok,
        Vec::new(),
        Vec::new(),
        v0,
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn5 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 if let HCO::NODE(r_0) = v0 { 
 let mut ref_0 = HCO::NODE(ASTNode::QueryBody(QueryBody::new(
        tok,
        Vec::new(),
        r_0,
        __NULL__,
    ) 
));;

                                args.push(ref_0);  }
                            }
fn _fn6 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 if let HCO::NODE(r_0) = v0 { 
 if let ASTNode::ContainerClause(r_1) = r_0 { 
 let mut ref_0 = HCO::NODE(ASTNode::QueryBody(QueryBody::new(
        tok,
        Some(r_1),
        Vec::new(),
        __NULL__,
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn7 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODES(r_0) = v1 { 
 if let HCO::NODE(r_1) = v2 { 
 if let ASTNode::IDENTIFIERS(r_2) = r_1 { 
 let mut ref_0 = HCO::NODE(ASTNode::ContainerClause(ContainerClause::new(
        tok,
        r_0,
        Some(r_2),
    ) 
));;

                                args.push(ref_0);  } } }
                            }
fn _fn8 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODES(r_0) = v0 { 
 if let HCO::NODE(r_1) = v1 { 
 if let ASTNode::IDENTIFIERS(r_2) = r_1 { 
 let mut ref_0 = HCO::NODE(ASTNode::ContainerClause(ContainerClause::new(
        tok,
        r_0,
        Some(r_2),
    ) 
));;

                                args.push(ref_0);  } } }
                            }
fn _fn9 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let ASTNode::IDENTIFIERS(r_1) = r_0 { 
 let mut ref_0 = HCO::NODE(ASTNode::ContainerClause(ContainerClause::new(
        tok,
        Vec::new(),
        Some(r_1),
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn10 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODES(r_0) = v1 { 
 let mut ref_0 = HCO::NODE(ASTNode::ContainerClause(ContainerClause::new(
        tok,
        r_0,
        Vec::new(),
    ) 
));;

                                args.push(ref_0);  }
                            }
fn _fn11 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 if let HCO::NODE(r_0) = v0 { 
 if let ASTNode::IDENTIFIERS(r_1) = r_0 { 
 let mut ref_0 = HCO::NODE(ASTNode::ContainerClause(ContainerClause::new(
        tok,
        Vec::new(),
        Some(r_1),
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn12 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 if let HCO::NODES(r_0) = v0 { 
 let mut ref_0 = HCO::NODE(ASTNode::ContainerClause(ContainerClause::new(
        tok,
        r_0,
        Vec::new(),
    ) 
));;

                                args.push(ref_0);  }
                            }
fn _fn13 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODE(r_0) = v0 { 
 if let HCO::NODE(r_1) = v2 { 
 let mut ref_0 = HCO::NODE(ASTNode::AND(AND::new(
        tok,
        r_0,
        r_1,
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn14 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODE(r_0) = v0 { 
 if let HCO::NODE(r_1) = v2 { 
 let mut ref_0 = HCO::NODE(ASTNode::OR(OR::new(
        tok,
        r_0,
        r_1,
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn15 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v1 { 
 let mut ref_0 = HCO::NODE(ASTNode::NOT(NOT::new(
        tok,
        r_0,
    ) 
));;

                                args.push(ref_0);  }
                            }
fn _fn16 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 let mut ref_0 = HCO::NODE(ASTNode::MATCH(MATCH::new(
        tok,
        v0,
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn17 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let HCO::NODE(r_1) = v2 { 
 if let ASTNode::ORDER(r_2) = r_1 { 
 let mut ref_0 = HCO::NODE(ASTNode::CREATED(CREATED::new(
        tok,
        r_0,
        Some(r_2),
    ) 
));;

                                args.push(ref_0);  } } }
                            }
fn _fn18 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let ASTNode::ORDER(r_1) = r_0 { 
 let mut ref_0 = HCO::NODE(ASTNode::CREATED(CREATED::new(
        tok,
        Vec::new(),
        Some(r_1),
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn19 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v1 { 
 let mut ref_0 = HCO::NODE(ASTNode::CREATED(CREATED::new(
        tok,
        r_0,
        Vec::new(),
    ) 
));;

                                args.push(ref_0);  }
                            }
fn _fn20 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 let mut ref_0 = HCO::NODE(ASTNode::CREATED(CREATED::new(
        tok,
        Vec::new(),
        Vec::new(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn21 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let HCO::NODE(r_1) = v2 { 
 if let ASTNode::ORDER(r_2) = r_1 { 
 let mut ref_0 = HCO::NODE(ASTNode::MODIFIED(MODIFIED::new(
        tok,
        r_0,
        Some(r_2),
    ) 
));;

                                args.push(ref_0);  } } }
                            }
fn _fn22 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let ASTNode::ORDER(r_1) = r_0 { 
 let mut ref_0 = HCO::NODE(ASTNode::MODIFIED(MODIFIED::new(
        tok,
        Vec::new(),
        Some(r_1),
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn23 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v1 { 
 let mut ref_0 = HCO::NODE(ASTNode::MODIFIED(MODIFIED::new(
        tok,
        r_0,
        Vec::new(),
    ) 
));;

                                args.push(ref_0);  }
                            }
fn _fn24 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 let mut ref_0 = HCO::NODE(ASTNode::MODIFIED(MODIFIED::new(
        tok,
        Vec::new(),
        Vec::new(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn25 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let HCO::NODE(r_1) = v2 { 
 if let ASTNode::ORDER(r_2) = r_1 { 
 let mut ref_0 = HCO::NODE(ASTNode::SIZE(SIZE::new(
        tok,
        r_0,
        Some(r_2),
    ) 
));;

                                args.push(ref_0);  } } }
                            }
fn _fn26 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v1 { 
 let mut ref_0 = HCO::NODE(ASTNode::SIZE(SIZE::new(
        tok,
        r_0,
        Vec::new(),
    ) 
));;

                                args.push(ref_0);  }
                            }
fn _fn27 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let ASTNode::IDENTIFIERS(r_1) = r_0 { 
 if let HCO::NODE(r_2) = v2 { 
 if let HCO::NODE(r_3) = v3 { 
 if let ASTNode::ORDER(r_4) = r_3 { 
 let mut ref_0 = HCO::NODE(ASTNode::TAG(TAG::new(
        tok,
        r_1,
        r_2,
        Some(r_4),
    ) 
));;

                                args.push(ref_0);  } } } } }
                            }
fn _fn28 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let ASTNode::IDENTIFIERS(r_1) = r_0 { 
 if let HCO::NODE(r_2) = v2 { 
 if let ASTNode::ORDER(r_3) = r_2 { 
 let mut ref_0 = HCO::NODE(ASTNode::TAG(TAG::new(
        tok,
        r_1,
        Vec::new(),
        Some(r_3),
    ) 
));;

                                args.push(ref_0);  } } } }
                            }
fn _fn29 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let ASTNode::IDENTIFIERS(r_1) = r_0 { 
 if let HCO::NODE(r_2) = v2 { 
 let mut ref_0 = HCO::NODE(ASTNode::TAG(TAG::new(
        tok,
        r_1,
        r_2,
        Vec::new(),
    ) 
));;

                                args.push(ref_0);  } } }
                            }
fn _fn30 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let ASTNode::IDENTIFIERS(r_1) = r_0 { 
 let mut ref_0 = HCO::NODE(ASTNode::TAG(TAG::new(
        tok,
        r_1,
        Vec::new(),
        Vec::new(),
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn31 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 let mut ref_0 = HCO::NODE(ASTNode::EQUALS_QUANTITATIVE(EQUALS_QUANTITATIVE::new(
        tok,
        v2.to_f64(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn32 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODE(r_0) = v2 { 
 if let ASTNode::IDENTIFIERS(r_1) = r_0 { 
 let mut ref_0 = HCO::NODE(ASTNode::EQUALS_QUALITATIVE(EQUALS_QUALITATIVE::new(
        tok,
        r_1,
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn33 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 let mut ref_0 = HCO::NODE(ASTNode::GREATERTHAN(GREATERTHAN::new(
        tok,
        v1.to_f64(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn34 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 let mut ref_0 = HCO::NODE(ASTNode::LESSTHAN(LESSTHAN::new(
        tok,
        v1.to_f64(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn35 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 let mut ref_0 = HCO::NODE(ASTNode::EQUALS_QUANTITATIVE(EQUALS_QUANTITATIVE::new(
        tok,
        v1.to_f64(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn36 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODE(r_0) = v1 { 
 if let ASTNode::IDENTIFIERS(r_1) = r_0 { 
 let mut ref_0 = HCO::NODE(ASTNode::EQUALS_QUALITATIVE(EQUALS_QUALITATIVE::new(
        tok,
        r_1,
    ) 
));;

                                args.push(ref_0);  } }
                            }
fn _fn37 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3);
                                
 let mut ref_0 = HCO::NODE(ASTNode::GREATERTHAN(GREATERTHAN::new(
        tok,
        v3.to_f64(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn38 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v3 = args.remove(i-0);
let mut v2 = args.remove(i-1);
let mut v1 = args.remove(i-2);
let mut v0 = args.remove(i-3);
                                
 let mut ref_0 = HCO::NODE(ASTNode::LESSTHAN(LESSTHAN::new(
        tok,
        v3.to_f64(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn39 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 let mut ref_0 = HCO::NODE(ASTNode::GREATERTHAN(GREATERTHAN::new(
        tok,
        v2.to_f64(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn40 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 let mut ref_0 = HCO::NODE(ASTNode::LESSTHAN(LESSTHAN::new(
        tok,
        v2.to_f64(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn41 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 let mut ref_0 = HCO::NODE(ASTNode::RANGE(RANGE::new(
        tok,
        v0.to_f64(),
        v1.to_f64(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn42 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 let mut ref_0 = HCO::NODE(ASTNode::RANGE(RANGE::new(
        tok,
        v0.to_f64(),
        v1.to_f64(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn43 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 let mut ref_0 = HCO::NODE(ASTNode::DATE(DATE::new(
        tok,
        v1.String(),
        v2.String(),
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn44 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 let mut ref_0 = HCO::NODE(ASTNode::DATE(DATE::new(
        tok,
        v1.String(),
        "",
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn45 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 let mut ref_0 = HCO::NODE(ASTNode::ORDER(ORDER::new(
        tok,
        1.0,
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn46 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 let mut ref_0 = HCO::NODE(ASTNode::IDENTIFIERS(IDENTIFIERS::new(
        tok,
        v0,
    ) 
));;

                                args.push(ref_0); 
                            }
fn _fn47 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                

                                args.push(v0); 
                            }
fn _fn48 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                

                                args.push(v2); 
                            }
fn _fn49 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                

                                args.push(v1); 
                            }
fn _fn50 (args:&mut Vec<HCO>, tok: Token){ 
                        let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                

                                args.push(v1); 
                            }
fn _fn51 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v0 = args.remove(i-0);
                                
 let mut ref_0:Vec<ASTNode> = Vec::new();
 if let HCO::NODE(r_0) = v0 { 
ref_0.push(r_0);
 }
                                args.push(HCO::NODES(ref_0)); } 
fn _fn52 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1);
                                
 if let HCO::NODES(r_0) = &mut v0 { 
 if let HCO::NODE(r_1) = v1 { 
r_0.push(r_1);
  } }
                                args.push(v0) } 
fn _fn53 (args:&mut Vec<HCO>, tok: Token){ 
                                let mut i = args.len()-1;
let mut v2 = args.remove(i-0);
let mut v1 = args.remove(i-1);
let mut v0 = args.remove(i-2);
                                
 if let HCO::NODES(r_0) = &mut v0 { 
 if let HCO::NODE(r_1) = v2 { 
r_0.push(r_1);
  } }
                                args.push(v0) } 
fn _fn54 (args:&mut Vec<HCO>, tok: Token){
                            let mut i = args.len()-1;
let mut v0 = args.remove(i-0); 
                                
 let mut ref_0 = &HCGObjStringArray{Val: [String] { &(v0).String()}};

                                args.push(ref_0); 
                            }
fn _fn55 (args:&mut Vec<HCO>, tok: Token){
                            let mut i = args.len()-1;
let mut v1 = args.remove(i-0);
let mut v0 = args.remove(i-1); 
                                
v0.(*HCGObjStringArray).Append(&(v1).String())

                                args.push(v0); 
                            }
fn _fn56 (args:&mut Vec<HCO>, tok: Token){}



pub const FunctionMaps:[RF; 168]= [
    _fn56,_fn56,_fn0,_fn1,_fn2,_fn3,_fn4,_fn5,_fn6,_fn7,_fn8,_fn9,_fn10,_fn11,_fn12,_fn47,_fn48,_fn48,_fn48,_fn48,_fn49,_fn49,_fn49,_fn49,_fn49,_fn56,_fn13,_fn13,_fn13,_fn13,_fn56,_fn14,_fn14,_fn14,_fn14,_fn56,_fn15,_fn15,_fn15,_fn15,_fn50,_fn16,_fn16,_fn56,_fn48,_fn49,_fn48,_fn48,_fn48,_fn49,_fn49,_fn56,_fn49,_fn49,_fn49,_fn49,_fn49,_fn49,_fn56,_fn56,_fn56,_fn56,_fn56,_fn56,_fn56,_fn56,_fn17,_fn17,_fn18,_fn19,_fn18,_fn19,_fn20,_fn20,_fn21,_fn21,_fn22,_fn23,_fn22,_fn23,_fn24,_fn24,_fn25,_fn25,_fn26,_fn26,_fn27,_fn28,_fn29,_fn30,_fn31,_fn32,_fn33,_fn34,_fn49,_fn49,_fn35,_fn35,_fn35,_fn36,_fn36,_fn36,_fn37,_fn33,_fn38,_fn34,_fn56,_fn56,_fn39,_fn40,_fn41,_fn42,_fn43,_fn43,_fn43,_fn44,_fn43,_fn44,_fn44,_fn44,_fn45,_fn45,_fn45,_fn45,_fn45,_fn45,_fn45,_fn45,_fn45,_fn45,_fn45,_fn45,_fn46,_fn56,_fn56,_fn50,_fn50,_fn49,_fn56,_fn56,_fn56,_fn56,_fn56,_fn49,_fn56,_fn56,_fn56,_fn51,_fn52,_fn51,_fn53,_fn49,_fn49,_fn49,_fn49,_fn49,_fn49,_fn49,_fn49,_fn49,_fn49,_fn49,_fn49,_fn49,_fn54,_fn55,_fn54,_fn55,
];
