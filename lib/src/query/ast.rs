/* **** DO NOT MODIFY **** DO NOT MODIFY **** DO NOT MODIFY ****
 *
 * This code has been automatically generated by Hydrocarbon Toolkit
 *
 * ###################################################################
 *
 * Copyright 2022 Anthony C. Weathersby
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

use std::cell::UnsafeCell;

use hctk::ast::{HCObj, HCObjTrait, ReduceFunction};

use hctk::Token;

type RF = ReduceFunction<ASTNode>;

type HCO = HCObj<ASTNode>;

#[derive(Debug, Clone)]
pub enum ASTNode {
    NONE,
    QueryBody(Box<QueryBody>),
    ContainerClause(Box<ContainerClause>),
    TextFrag(Box<TextFrag>),
    WildCard(Box<WildCard>),
    AND(Box<AND>),
    OR(Box<OR>),
    NOT(Box<NOT>),
    MATCH(Box<MATCH>),
    CREATED(Box<CREATED>),
    MODIFIED(Box<MODIFIED>),
    SIZE(Box<SIZE>),
    TAG(Box<TAG>),
    EQUALS_QUANTITATIVE(Box<EQUALS_QUANTITATIVE>),
    EQUALS_QUALITATIVE(Box<EQUALS_QUALITATIVE>),
    GREATERTHAN(Box<GREATERTHAN>),
    LESSTHAN(Box<LESSTHAN>),
    RANGE(Box<RANGE>),
    DATE(Box<DATE>),
    ORDER(Box<ORDER>),
    IDENTIFIER(Box<IDENTIFIER>),
    PathPart(Box<PathPart>),
}

impl HCObjTrait for ASTNode {
    fn String(&self) -> String {
        use ASTNode::*;

        return "".to_string();
        /*
        match self {

            QueryBody(bx) => bx.tok.String(),

            ContainerClause(bx) => bx.tok.String(),

            TextFrag(bx) => bx.tok.String(),

            WildCard(bx) => bx.tok.String(),

            AND(bx) => bx.tok.String(),

            OR(bx) => bx.tok.String(),

            NOT(bx) => bx.tok.String(),

            MATCH(bx) => bx.tok.String(),

            CREATED(bx) => bx.tok.String(),

            MODIFIED(bx) => bx.tok.String(),

            SIZE(bx) => bx.tok.String(),

            TAG(bx) => bx.tok.String(),

            EQUALS_QUANTITATIVE(bx) => bx.tok.String(),

            EQUALS_QUALITATIVE(bx) => bx.tok.String(),

            GREATERTHAN(bx) => bx.tok.String(),

            LESSTHAN(bx) => bx.tok.String(),

            RANGE(bx) => bx.tok.String(),

            DATE(bx) => bx.tok.String(),

            ORDER(bx) => bx.tok.String(),

            IDENTIFIER(bx) => bx.tok.String(),

            PathPart(bx) => bx.tok.String(),
            _ => String::from(""),
        } */
    }
}

#[derive(Debug)]
pub enum NodeIteration<'a> {
    NONE,
    STOP,
    CONTINUE,
    REPLACE(ASTNode),
    QueryBody(&'a mut QueryBody),
    ContainerClause(&'a mut ContainerClause),
    TextFrag(&'a mut TextFrag),
    WildCard(&'a mut WildCard),
    AND(&'a mut AND),
    OR(&'a mut OR),
    NOT(&'a mut NOT),
    MATCH(&'a mut MATCH),
    CREATED(&'a mut CREATED),
    MODIFIED(&'a mut MODIFIED),
    SIZE(&'a mut SIZE),
    TAG(&'a mut TAG),
    EQUALS_QUANTITATIVE(&'a mut EQUALS_QUANTITATIVE),
    EQUALS_QUALITATIVE(&'a mut EQUALS_QUALITATIVE),
    GREATERTHAN(&'a mut GREATERTHAN),
    LESSTHAN(&'a mut LESSTHAN),
    RANGE(&'a mut RANGE),
    DATE(&'a mut DATE),
    ORDER(&'a mut ORDER),
    IDENTIFIER(&'a mut IDENTIFIER),
    PathPart(&'a mut PathPart),
}

impl<'a> NodeIteration<'a> {
    pub fn name(&self) -> &str {
        use NodeIteration::*;
        match self {
            STOP => "stop",

            QueryBody(_0) => "node-QueryBody",
            ContainerClause(_0) => "node-ContainerClause",
            TextFrag(_0) => "node-TextFrag",
            WildCard(_0) => "node-WildCard",
            AND(_0) => "node-AND",
            OR(_0) => "node-OR",
            NOT(_0) => "node-NOT",
            MATCH(_0) => "node-MATCH",
            CREATED(_0) => "node-CREATED",
            MODIFIED(_0) => "node-MODIFIED",
            SIZE(_0) => "node-SIZE",
            TAG(_0) => "node-TAG",
            EQUALS_QUANTITATIVE(_0) => "node-EQUALS_QUANTITATIVE",
            EQUALS_QUALITATIVE(_0) => "node-EQUALS_QUALITATIVE",
            GREATERTHAN(_0) => "node-GREATERTHAN",
            LESSTHAN(_0) => "node-LESSTHAN",
            RANGE(_0) => "node-RANGE",
            DATE(_0) => "node-DATE",
            ORDER(_0) => "node-ORDER",
            IDENTIFIER(_0) => "node-IDENTIFIER",
            PathPart(_0) => "node-PathPart",
            REPLACE(node) => "replace",
            _ => "unknown",
        }
    }
}

pub trait ASTNodeTraits<'a>
where
    Self: Sized,
{
    fn iterate(
        self: &'a mut Box<Self>,
        _yield: &'a mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>) -> NodeIteration<'a>,
    ) {
        let mut closure =
            |a: &mut NodeIteration<'a>, b: &mut NodeIteration<'a>, ty: u32, c: i32, d: i32| {
                use NodeIteration::*;
                match _yield(a, b) {
                    STOP => false,
                    REPLACE(node) => match b {
                        QueryBody(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        ContainerClause(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        TextFrag(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        WildCard(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        AND(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        OR(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        NOT(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        MATCH(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        CREATED(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        MODIFIED(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        SIZE(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        TAG(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        EQUALS_QUANTITATIVE(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        EQUALS_QUALITATIVE(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        GREATERTHAN(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        LESSTHAN(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        RANGE(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        DATE(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        ORDER(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        IDENTIFIER(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        PathPart(par) => {
                            par.Replace(node, c, d);
                            true
                        }
                        _ => true,
                    },
                    _ => true,
                }
            };

        self.Iterate(&mut closure, &mut NodeIteration::NONE, 0, 0)
    }
    fn Replace(&mut self, node: ASTNode, i: i32, j: i32) -> ASTNode {
        ASTNode::NONE
    }
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    );
    fn Token(&self) -> Token;
    fn Type() -> u32;
    fn GetType(&self) -> u32;

    //fn serialize(ByteWriter) -> none
    //fn deserialize(ByteReader) -> Self
}

impl<'a> ASTNodeTraits<'a> for ASTNode
where
    Self: Sized,
{
    fn Replace(&mut self, n: ASTNode, i: i32, j: i32) -> ASTNode {
        use ASTNode::*;
        match self {
            _ => ASTNode::NONE,

            QueryBody(node) => node.as_mut().Replace(n, i, j),
            ContainerClause(node) => node.as_mut().Replace(n, i, j),
            TextFrag(node) => node.as_mut().Replace(n, i, j),
            WildCard(node) => node.as_mut().Replace(n, i, j),
            AND(node) => node.as_mut().Replace(n, i, j),
            OR(node) => node.as_mut().Replace(n, i, j),
            NOT(node) => node.as_mut().Replace(n, i, j),
            MATCH(node) => node.as_mut().Replace(n, i, j),
            CREATED(node) => node.as_mut().Replace(n, i, j),
            MODIFIED(node) => node.as_mut().Replace(n, i, j),
            SIZE(node) => node.as_mut().Replace(n, i, j),
            TAG(node) => node.as_mut().Replace(n, i, j),
            EQUALS_QUANTITATIVE(node) => node.as_mut().Replace(n, i, j),
            EQUALS_QUALITATIVE(node) => node.as_mut().Replace(n, i, j),
            GREATERTHAN(node) => node.as_mut().Replace(n, i, j),
            LESSTHAN(node) => node.as_mut().Replace(n, i, j),
            RANGE(node) => node.as_mut().Replace(n, i, j),
            DATE(node) => node.as_mut().Replace(n, i, j),
            ORDER(node) => node.as_mut().Replace(n, i, j),
            IDENTIFIER(node) => node.as_mut().Replace(n, i, j),
            PathPart(node) => node.as_mut().Replace(n, i, j),
        }
    }

    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        use ASTNode::*;
        match self {
            _ => {}

            QueryBody(node) => node.as_mut().Iterate(_yield, parent, i, j),
            ContainerClause(node) => node.as_mut().Iterate(_yield, parent, i, j),
            TextFrag(node) => node.as_mut().Iterate(_yield, parent, i, j),
            WildCard(node) => node.as_mut().Iterate(_yield, parent, i, j),
            AND(node) => node.as_mut().Iterate(_yield, parent, i, j),
            OR(node) => node.as_mut().Iterate(_yield, parent, i, j),
            NOT(node) => node.as_mut().Iterate(_yield, parent, i, j),
            MATCH(node) => node.as_mut().Iterate(_yield, parent, i, j),
            CREATED(node) => node.as_mut().Iterate(_yield, parent, i, j),
            MODIFIED(node) => node.as_mut().Iterate(_yield, parent, i, j),
            SIZE(node) => node.as_mut().Iterate(_yield, parent, i, j),
            TAG(node) => node.as_mut().Iterate(_yield, parent, i, j),
            EQUALS_QUANTITATIVE(node) => node.as_mut().Iterate(_yield, parent, i, j),
            EQUALS_QUALITATIVE(node) => node.as_mut().Iterate(_yield, parent, i, j),
            GREATERTHAN(node) => node.as_mut().Iterate(_yield, parent, i, j),
            LESSTHAN(node) => node.as_mut().Iterate(_yield, parent, i, j),
            RANGE(node) => node.as_mut().Iterate(_yield, parent, i, j),
            DATE(node) => node.as_mut().Iterate(_yield, parent, i, j),
            ORDER(node) => node.as_mut().Iterate(_yield, parent, i, j),
            IDENTIFIER(node) => node.as_mut().Iterate(_yield, parent, i, j),
            PathPart(node) => node.as_mut().Iterate(_yield, parent, i, j),
        }
    }

    fn Token(&self) -> Token {
        use ASTNode::*;
        match self {
            _ => Token::empty(),

            QueryBody(node) => node.as_ref().Token(),
            ContainerClause(node) => node.as_ref().Token(),
            TextFrag(node) => node.as_ref().Token(),
            WildCard(node) => node.as_ref().Token(),
            AND(node) => node.as_ref().Token(),
            OR(node) => node.as_ref().Token(),
            NOT(node) => node.as_ref().Token(),
            MATCH(node) => node.as_ref().Token(),
            CREATED(node) => node.as_ref().Token(),
            MODIFIED(node) => node.as_ref().Token(),
            SIZE(node) => node.as_ref().Token(),
            TAG(node) => node.as_ref().Token(),
            EQUALS_QUANTITATIVE(node) => node.as_ref().Token(),
            EQUALS_QUALITATIVE(node) => node.as_ref().Token(),
            GREATERTHAN(node) => node.as_ref().Token(),
            LESSTHAN(node) => node.as_ref().Token(),
            RANGE(node) => node.as_ref().Token(),
            DATE(node) => node.as_ref().Token(),
            ORDER(node) => node.as_ref().Token(),
            IDENTIFIER(node) => node.as_ref().Token(),
            PathPart(node) => node.as_ref().Token(),
        }
    }

    fn GetType(&self) -> u32 {
        use ASTNode::*;
        match self {
            _ => 0,

            QueryBody(node) => node.as_ref().GetType(),
            ContainerClause(node) => node.as_ref().GetType(),
            TextFrag(node) => node.as_ref().GetType(),
            WildCard(node) => node.as_ref().GetType(),
            AND(node) => node.as_ref().GetType(),
            OR(node) => node.as_ref().GetType(),
            NOT(node) => node.as_ref().GetType(),
            MATCH(node) => node.as_ref().GetType(),
            CREATED(node) => node.as_ref().GetType(),
            MODIFIED(node) => node.as_ref().GetType(),
            SIZE(node) => node.as_ref().GetType(),
            TAG(node) => node.as_ref().GetType(),
            EQUALS_QUANTITATIVE(node) => node.as_ref().GetType(),
            EQUALS_QUALITATIVE(node) => node.as_ref().GetType(),
            GREATERTHAN(node) => node.as_ref().GetType(),
            LESSTHAN(node) => node.as_ref().GetType(),
            RANGE(node) => node.as_ref().GetType(),
            DATE(node) => node.as_ref().GetType(),
            ORDER(node) => node.as_ref().GetType(),
            IDENTIFIER(node) => node.as_ref().GetType(),
            PathPart(node) => node.as_ref().GetType(),
        }
    }

    fn Type() -> u32 {
        0
    }
}

#[derive(Debug, Clone)]
pub struct QueryBody {
    pub container: Option<Box<ContainerClause>>, /* ContainerClause */
    pub filter: ASTNode, /* AND | OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG */
    pub sort: Vec<ASTNode>, /* VECTOR */
}

impl QueryBody {
    fn new(
        tok: Token,
        _container: Option<Box<ContainerClause>>,
        _filter: ASTNode,
        _sort: Vec<ASTNode>,
    ) -> Box<Self> {
        Box::new(QueryBody {
            container: _container,
            filter: _filter,
            sort: _sort,
        })
    }

    fn replace_container(&mut self, child: ASTNode) -> Option<ASTNode> {
        match child {
            ASTNode::NONE => {
                if self.container.is_some() {
                    let old = std::mem::replace(&mut self.container, None);
                    if let Some(old_node) = old {
                        return Some(ASTNode::ContainerClause(old_node));
                    }
                }
            }

            ASTNode::ContainerClause(child) => {
                if self.container.is_none() {
                    self.container = Some(child);
                } else {
                    let old = std::mem::replace(&mut self.container, Some(child));

                    if let Some(old_node) = old {
                        return Some(ASTNode::ContainerClause(old_node));
                    }
                }
            }
            _ => {}
        }
        None
    }

    fn replace_filter(&mut self, child: ASTNode) -> Option<ASTNode> {
        match &child {
            ASTNode::NONE => {
                let old = std::mem::replace(&mut self.filter, ASTNode::NONE);
                return Some(old);
            }

            ASTNode::AND(_) => {
                return Some(std::mem::replace(&mut self.filter, child));
            }

            ASTNode::OR(_) => {
                return Some(std::mem::replace(&mut self.filter, child));
            }

            ASTNode::NOT(_) => {
                return Some(std::mem::replace(&mut self.filter, child));
            }

            ASTNode::MATCH(_) => {
                return Some(std::mem::replace(&mut self.filter, child));
            }

            ASTNode::CREATED(_) => {
                return Some(std::mem::replace(&mut self.filter, child));
            }

            ASTNode::MODIFIED(_) => {
                return Some(std::mem::replace(&mut self.filter, child));
            }

            ASTNode::SIZE(_) => {
                return Some(std::mem::replace(&mut self.filter, child));
            }

            ASTNode::TAG(_) => {
                return Some(std::mem::replace(&mut self.filter, child));
            }
            _ => None,
        }
    }

    fn replace_sort(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
        match &child {
            ASTNode::CREATED(_) | ASTNode::MODIFIED(_) | ASTNode::SIZE(_) | ASTNode::TAG(_) => {
                if index as usize >= self.sort.len() {
                    self.sort.push(child);
                    None
                } else {
                    self.sort.push(child);
                    let node = self.sort.swap_remove(index as usize);
                    Some(node)
                }
            }
            ASTNode::NONE => {
                if (index as usize) < self.sort.len() {
                    let node = self.sort.remove(index as usize);
                    Some(node)
                } else {
                    None
                }
            }
            _ => None,
        }
    }
}

impl<'a> ASTNodeTraits<'a> for QueryBody
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::QueryBody(*mut_me), parent, 22, i, j) {
                return;
            };
        }

        unsafe {
            let reference = node.get();
            if let Some(child) = &mut (*reference).container
            /* HAS_NULL:true */
            {
                let mut_me_b = node.get();
                child.Iterate(_yield, &mut NodeIteration::QueryBody(*mut_me_b), 0, 0);
            }
        }

        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).filter
            /* HAS_NULL:true */
            {
                let mut_me_b = node.get();
                child.Iterate(_yield, &mut NodeIteration::QueryBody(*mut_me_b), 1, 0);
            }
        }

        unsafe {
            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).sort.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).sort[j];

                match child {
                    ASTNode::CREATED(child) => {
                        unsafe {
                            let mut_me = node.get();
                            child.Iterate(
                                _yield,
                                &mut NodeIteration::QueryBody(*mut_me),
                                2,
                                j as i32,
                            )
                        };
                    }

                    ASTNode::MODIFIED(child) => {
                        unsafe {
                            let mut_me = node.get();
                            child.Iterate(
                                _yield,
                                &mut NodeIteration::QueryBody(*mut_me),
                                2,
                                j as i32,
                            )
                        };
                    }

                    ASTNode::SIZE(child) => {
                        unsafe {
                            let mut_me = node.get();
                            child.Iterate(
                                _yield,
                                &mut NodeIteration::QueryBody(*mut_me),
                                2,
                                j as i32,
                            )
                        };
                    }

                    ASTNode::TAG(child) => {
                        unsafe {
                            let mut_me = node.get();
                            child.Iterate(
                                _yield,
                                &mut NodeIteration::QueryBody(*mut_me),
                                2,
                                j as i32,
                            )
                        };
                    }
                    _ => {}
                }
            }
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_container(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            1 => {
                if let Some(old) = self.replace_filter(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            2 => {
                if let Some(old) = self.replace_sort(child, j) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 22;
    }

    fn GetType(&self) -> u32 {
        return 22;
    }
}

#[derive(Debug, Clone)]
pub struct ContainerClause {
    pub path: Vec<ASTNode>, /* VECTOR */
    pub PATH_ONLY: bool,    /* BOOL */
}

impl ContainerClause {
    fn new(tok: Token, _path: Vec<ASTNode>, _PATH_ONLY: bool) -> Box<Self> {
        Box::new(ContainerClause {
            path: _path,
            PATH_ONLY: _PATH_ONLY,
        })
    }

    fn replace_path(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
        match &child {
            ASTNode::PathPart(_) => {
                if index as usize >= self.path.len() {
                    self.path.push(child);
                    None
                } else {
                    self.path.push(child);
                    let node = self.path.swap_remove(index as usize);
                    Some(node)
                }
            }
            ASTNode::NONE => {
                if (index as usize) < self.path.len() {
                    let node = self.path.remove(index as usize);
                    Some(node)
                } else {
                    None
                }
            }
            _ => None,
        }
    }
}

impl<'a> ASTNodeTraits<'a> for ContainerClause
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(
                &mut NodeIteration::ContainerClause(*mut_me),
                parent,
                24,
                i,
                j,
            ) {
                return;
            };
        }

        unsafe {
            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).path.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).path[j];

                if let ASTNode::PathPart(child) = child {
                    unsafe {
                        let mut_me = node.get();
                        child.Iterate(
                            _yield,
                            &mut NodeIteration::ContainerClause(*mut_me),
                            0,
                            j as i32,
                        )
                    };
                }
            }
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_path(child, j) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 24;
    }

    fn GetType(&self) -> u32 {
        return 24;
    }
}

#[derive(Debug, Clone)]
pub struct TextFrag {
    pub val: String, /* STRING | STRING */
}

impl TextFrag {
    fn new(tok: Token, _val: String) -> Box<Self> {
        Box::new(TextFrag { val: _val })
    }
}

impl<'a> ASTNodeTraits<'a> for TextFrag
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::TextFrag(*mut_me), parent, 26, i, j) {
                return;
            };
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 26;
    }

    fn GetType(&self) -> u32 {
        return 26;
    }
}

#[derive(Debug, Clone)]
pub struct WildCard {}

impl WildCard {
    fn new(tok: Token) -> Box<Self> {
        Box::new(WildCard {})
    }
}

impl<'a> ASTNodeTraits<'a> for WildCard
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::WildCard(*mut_me), parent, 28, i, j) {
                return;
            };
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 28;
    }

    fn GetType(&self) -> u32 {
        return 28;
    }
}

#[derive(Debug, Clone)]
pub struct AND {
    pub left: ASTNode,  /* OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG */
    pub right: ASTNode, /* AND | OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG */
}

impl AND {
    fn new(tok: Token, _left: ASTNode, _right: ASTNode) -> Box<Self> {
        Box::new(AND {
            left: _left,
            right: _right,
        })
    }

    fn replace_left(&mut self, child: ASTNode) -> Option<ASTNode> {
        match &child {
            ASTNode::NONE => {
                let old = std::mem::replace(&mut self.left, ASTNode::NONE);
                return Some(old);
            }

            ASTNode::OR(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::NOT(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::MATCH(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::CREATED(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::MODIFIED(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::SIZE(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::TAG(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }
            _ => None,
        }
    }

    fn replace_right(&mut self, child: ASTNode) -> Option<ASTNode> {
        match &child {
            ASTNode::NONE => {
                let old = std::mem::replace(&mut self.right, ASTNode::NONE);
                return Some(old);
            }

            ASTNode::AND(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::OR(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::NOT(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::MATCH(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::CREATED(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::MODIFIED(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::SIZE(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::TAG(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }
            _ => None,
        }
    }
}

impl<'a> ASTNodeTraits<'a> for AND
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::AND(*mut_me), parent, 30, i, j) {
                return;
            };
        }

        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).left).Iterate(_yield, &mut NodeIteration::AND(*mut_me_b), 0, 0);
        }

        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).right).Iterate(_yield, &mut NodeIteration::AND(*mut_me_b), 1, 0);
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_left(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            1 => {
                if let Some(old) = self.replace_right(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 30;
    }

    fn GetType(&self) -> u32 {
        return 30;
    }
}

#[derive(Debug, Clone)]
pub struct OR {
    pub left: ASTNode,  /* NOT | MATCH | CREATED | MODIFIED | SIZE | TAG */
    pub right: ASTNode, /* OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG */
}

impl OR {
    fn new(tok: Token, _left: ASTNode, _right: ASTNode) -> Box<Self> {
        Box::new(OR {
            left: _left,
            right: _right,
        })
    }

    fn replace_left(&mut self, child: ASTNode) -> Option<ASTNode> {
        match &child {
            ASTNode::NONE => {
                let old = std::mem::replace(&mut self.left, ASTNode::NONE);
                return Some(old);
            }

            ASTNode::NOT(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::MATCH(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::CREATED(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::MODIFIED(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::SIZE(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::TAG(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }
            _ => None,
        }
    }

    fn replace_right(&mut self, child: ASTNode) -> Option<ASTNode> {
        match &child {
            ASTNode::NONE => {
                let old = std::mem::replace(&mut self.right, ASTNode::NONE);
                return Some(old);
            }

            ASTNode::OR(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::NOT(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::MATCH(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::CREATED(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::MODIFIED(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::SIZE(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }

            ASTNode::TAG(_) => {
                return Some(std::mem::replace(&mut self.right, child));
            }
            _ => None,
        }
    }
}

impl<'a> ASTNodeTraits<'a> for OR
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::OR(*mut_me), parent, 32, i, j) {
                return;
            };
        }

        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).left).Iterate(_yield, &mut NodeIteration::OR(*mut_me_b), 0, 0);
        }

        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).right).Iterate(_yield, &mut NodeIteration::OR(*mut_me_b), 1, 0);
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_left(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            1 => {
                if let Some(old) = self.replace_right(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 32;
    }

    fn GetType(&self) -> u32 {
        return 32;
    }
}

#[derive(Debug, Clone)]
pub struct NOT {
    pub left: ASTNode, /* MATCH | CREATED | MODIFIED | SIZE | TAG */
}

impl NOT {
    fn new(tok: Token, _left: ASTNode) -> Box<Self> {
        Box::new(NOT { left: _left })
    }

    fn replace_left(&mut self, child: ASTNode) -> Option<ASTNode> {
        match &child {
            ASTNode::NONE => {
                let old = std::mem::replace(&mut self.left, ASTNode::NONE);
                return Some(old);
            }

            ASTNode::MATCH(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::CREATED(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::MODIFIED(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::SIZE(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }

            ASTNode::TAG(_) => {
                return Some(std::mem::replace(&mut self.left, child));
            }
            _ => None,
        }
    }
}

impl<'a> ASTNodeTraits<'a> for NOT
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::NOT(*mut_me), parent, 34, i, j) {
                return;
            };
        }

        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).left).Iterate(_yield, &mut NodeIteration::NOT(*mut_me_b), 0, 0);
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_left(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 34;
    }

    fn GetType(&self) -> u32 {
        return 34;
    }
}

#[derive(Debug, Clone)]
pub struct MATCH {
    pub value: String, /* STRING */
}

impl MATCH {
    fn new(tok: Token, _value: String) -> Box<Self> {
        Box::new(MATCH { value: _value })
    }
}

impl<'a> ASTNodeTraits<'a> for MATCH
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::MATCH(*mut_me), parent, 36, i, j) {
                return;
            };
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 36;
    }

    fn GetType(&self) -> u32 {
        return 36;
    }
}

#[derive(Debug, Clone)]
pub struct CREATED {
    pub val: ASTNode, /* EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE */
    pub order: Option<Box<ORDER>>, /* ORDER */
}

impl CREATED {
    fn new(tok: Token, _val: ASTNode, _order: Option<Box<ORDER>>) -> Box<Self> {
        Box::new(CREATED {
            val: _val,
            order: _order,
        })
    }

    fn replace_val(&mut self, child: ASTNode) -> Option<ASTNode> {
        match &child {
            ASTNode::NONE => {
                let old = std::mem::replace(&mut self.val, ASTNode::NONE);
                return Some(old);
            }

            ASTNode::EQUALS_QUANTITATIVE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::EQUALS_QUALITATIVE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::GREATERTHAN(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::LESSTHAN(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::RANGE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::DATE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }
            _ => None,
        }
    }

    fn replace_order(&mut self, child: ASTNode) -> Option<ASTNode> {
        match child {
            ASTNode::NONE => {
                if self.order.is_some() {
                    let old = std::mem::replace(&mut self.order, None);
                    if let Some(old_node) = old {
                        return Some(ASTNode::ORDER(old_node));
                    }
                }
            }

            ASTNode::ORDER(child) => {
                if self.order.is_none() {
                    self.order = Some(child);
                } else {
                    let old = std::mem::replace(&mut self.order, Some(child));

                    if let Some(old_node) = old {
                        return Some(ASTNode::ORDER(old_node));
                    }
                }
            }
            _ => {}
        }
        None
    }
}

impl<'a> ASTNodeTraits<'a> for CREATED
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::CREATED(*mut_me), parent, 38, i, j) {
                return;
            };
        }

        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).val
            /* HAS_NULL:true */
            {
                let mut_me_b = node.get();
                child.Iterate(_yield, &mut NodeIteration::CREATED(*mut_me_b), 0, 0);
            }
        }

        unsafe {
            let reference = node.get();
            if let Some(child) = &mut (*reference).order
            /* HAS_NULL:true */
            {
                let mut_me_b = node.get();
                child.Iterate(_yield, &mut NodeIteration::CREATED(*mut_me_b), 1, 0);
            }
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_val(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            1 => {
                if let Some(old) = self.replace_order(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 38;
    }

    fn GetType(&self) -> u32 {
        return 38;
    }
}

#[derive(Debug, Clone)]
pub struct MODIFIED {
    pub val: ASTNode, /* EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE */
    pub order: Option<Box<ORDER>>, /* ORDER */
}

impl MODIFIED {
    fn new(tok: Token, _val: ASTNode, _order: Option<Box<ORDER>>) -> Box<Self> {
        Box::new(MODIFIED {
            val: _val,
            order: _order,
        })
    }

    fn replace_val(&mut self, child: ASTNode) -> Option<ASTNode> {
        match &child {
            ASTNode::NONE => {
                let old = std::mem::replace(&mut self.val, ASTNode::NONE);
                return Some(old);
            }

            ASTNode::EQUALS_QUANTITATIVE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::EQUALS_QUALITATIVE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::GREATERTHAN(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::LESSTHAN(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::RANGE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::DATE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }
            _ => None,
        }
    }

    fn replace_order(&mut self, child: ASTNode) -> Option<ASTNode> {
        match child {
            ASTNode::NONE => {
                if self.order.is_some() {
                    let old = std::mem::replace(&mut self.order, None);
                    if let Some(old_node) = old {
                        return Some(ASTNode::ORDER(old_node));
                    }
                }
            }

            ASTNode::ORDER(child) => {
                if self.order.is_none() {
                    self.order = Some(child);
                } else {
                    let old = std::mem::replace(&mut self.order, Some(child));

                    if let Some(old_node) = old {
                        return Some(ASTNode::ORDER(old_node));
                    }
                }
            }
            _ => {}
        }
        None
    }
}

impl<'a> ASTNodeTraits<'a> for MODIFIED
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::MODIFIED(*mut_me), parent, 40, i, j) {
                return;
            };
        }

        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).val
            /* HAS_NULL:true */
            {
                let mut_me_b = node.get();
                child.Iterate(_yield, &mut NodeIteration::MODIFIED(*mut_me_b), 0, 0);
            }
        }

        unsafe {
            let reference = node.get();
            if let Some(child) = &mut (*reference).order
            /* HAS_NULL:true */
            {
                let mut_me_b = node.get();
                child.Iterate(_yield, &mut NodeIteration::MODIFIED(*mut_me_b), 1, 0);
            }
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_val(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            1 => {
                if let Some(old) = self.replace_order(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 40;
    }

    fn GetType(&self) -> u32 {
        return 40;
    }
}

#[derive(Debug, Clone)]
pub struct SIZE {
    pub val: ASTNode, /* EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE */
    pub order: Option<Box<ORDER>>, /* ORDER */
}

impl SIZE {
    fn new(tok: Token, _val: ASTNode, _order: Option<Box<ORDER>>) -> Box<Self> {
        Box::new(SIZE {
            val: _val,
            order: _order,
        })
    }

    fn replace_val(&mut self, child: ASTNode) -> Option<ASTNode> {
        match &child {
            ASTNode::NONE => {
                let old = std::mem::replace(&mut self.val, ASTNode::NONE);
                return Some(old);
            }

            ASTNode::EQUALS_QUANTITATIVE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::EQUALS_QUALITATIVE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::GREATERTHAN(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::LESSTHAN(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::RANGE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::DATE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }
            _ => None,
        }
    }

    fn replace_order(&mut self, child: ASTNode) -> Option<ASTNode> {
        match child {
            ASTNode::NONE => {
                if self.order.is_some() {
                    let old = std::mem::replace(&mut self.order, None);
                    if let Some(old_node) = old {
                        return Some(ASTNode::ORDER(old_node));
                    }
                }
            }

            ASTNode::ORDER(child) => {
                if self.order.is_none() {
                    self.order = Some(child);
                } else {
                    let old = std::mem::replace(&mut self.order, Some(child));

                    if let Some(old_node) = old {
                        return Some(ASTNode::ORDER(old_node));
                    }
                }
            }
            _ => {}
        }
        None
    }
}

impl<'a> ASTNodeTraits<'a> for SIZE
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::SIZE(*mut_me), parent, 42, i, j) {
                return;
            };
        }

        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).val).Iterate(_yield, &mut NodeIteration::SIZE(*mut_me_b), 0, 0);
        }

        unsafe {
            let reference = node.get();
            if let Some(child) = &mut (*reference).order
            /* HAS_NULL:true */
            {
                let mut_me_b = node.get();
                child.Iterate(_yield, &mut NodeIteration::SIZE(*mut_me_b), 1, 0);
            }
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_val(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            1 => {
                if let Some(old) = self.replace_order(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 42;
    }

    fn GetType(&self) -> u32 {
        return 42;
    }
}

#[derive(Debug, Clone)]
pub struct TAG {
    pub id: Box<IDENTIFIER>,       /* IDENTIFIER */
    pub val: ASTNode, /* EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE */
    pub order: Option<Box<ORDER>>, /* ORDER */
}

impl TAG {
    fn new(
        tok: Token,
        _id: Box<IDENTIFIER>,
        _val: ASTNode,
        _order: Option<Box<ORDER>>,
    ) -> Box<Self> {
        Box::new(TAG {
            id: _id,
            val: _val,
            order: _order,
        })
    }

    fn replace_id(&mut self, child: ASTNode) -> Option<ASTNode> {
        if let ASTNode::IDENTIFIER(child) = child {
            return Some(ASTNode::IDENTIFIER(std::mem::replace(&mut self.id, child)));
        } else {
            return None;
        }
    }

    fn replace_val(&mut self, child: ASTNode) -> Option<ASTNode> {
        match &child {
            ASTNode::NONE => {
                let old = std::mem::replace(&mut self.val, ASTNode::NONE);
                return Some(old);
            }

            ASTNode::EQUALS_QUANTITATIVE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::EQUALS_QUALITATIVE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::GREATERTHAN(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::LESSTHAN(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::RANGE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }

            ASTNode::DATE(_) => {
                return Some(std::mem::replace(&mut self.val, child));
            }
            _ => None,
        }
    }

    fn replace_order(&mut self, child: ASTNode) -> Option<ASTNode> {
        match child {
            ASTNode::NONE => {
                if self.order.is_some() {
                    let old = std::mem::replace(&mut self.order, None);
                    if let Some(old_node) = old {
                        return Some(ASTNode::ORDER(old_node));
                    }
                }
            }

            ASTNode::ORDER(child) => {
                if self.order.is_none() {
                    self.order = Some(child);
                } else {
                    let old = std::mem::replace(&mut self.order, Some(child));

                    if let Some(old_node) = old {
                        return Some(ASTNode::ORDER(old_node));
                    }
                }
            }
            _ => {}
        }
        None
    }
}

impl<'a> ASTNodeTraits<'a> for TAG
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::TAG(*mut_me), parent, 44, i, j) {
                return;
            };
        }

        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).id).Iterate(_yield, &mut NodeIteration::TAG(*mut_me_b), 0, 0);
        }

        unsafe {
            let reference = node.get();
            if let child = &mut (*reference).val
            /* HAS_NULL:true */
            {
                let mut_me_b = node.get();
                child.Iterate(_yield, &mut NodeIteration::TAG(*mut_me_b), 1, 0);
            }
        }

        unsafe {
            let reference = node.get();
            if let Some(child) = &mut (*reference).order
            /* HAS_NULL:true */
            {
                let mut_me_b = node.get();
                child.Iterate(_yield, &mut NodeIteration::TAG(*mut_me_b), 2, 0);
            }
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_id(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            1 => {
                if let Some(old) = self.replace_val(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            2 => {
                if let Some(old) = self.replace_order(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 44;
    }

    fn GetType(&self) -> u32 {
        return 44;
    }
}

#[derive(Debug, Clone)]
pub struct EQUALS_QUANTITATIVE {
    pub val: f64, /* F64 */
}

impl EQUALS_QUANTITATIVE {
    fn new(tok: Token, _val: f64) -> Box<Self> {
        Box::new(EQUALS_QUANTITATIVE { val: _val })
    }
}

impl<'a> ASTNodeTraits<'a> for EQUALS_QUANTITATIVE
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(
                &mut NodeIteration::EQUALS_QUANTITATIVE(*mut_me),
                parent,
                46,
                i,
                j,
            ) {
                return;
            };
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 46;
    }

    fn GetType(&self) -> u32 {
        return 46;
    }
}

#[derive(Debug, Clone)]
pub struct EQUALS_QUALITATIVE {
    pub val: Box<IDENTIFIER>, /* IDENTIFIER */
}

impl EQUALS_QUALITATIVE {
    fn new(tok: Token, _val: Box<IDENTIFIER>) -> Box<Self> {
        Box::new(EQUALS_QUALITATIVE { val: _val })
    }

    fn replace_val(&mut self, child: ASTNode) -> Option<ASTNode> {
        if let ASTNode::IDENTIFIER(child) = child {
            return Some(ASTNode::IDENTIFIER(std::mem::replace(&mut self.val, child)));
        } else {
            return None;
        }
    }
}

impl<'a> ASTNodeTraits<'a> for EQUALS_QUALITATIVE
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(
                &mut NodeIteration::EQUALS_QUALITATIVE(*mut_me),
                parent,
                48,
                i,
                j,
            ) {
                return;
            };
        }

        unsafe {
            let mut_me_b = node.get();
            let mut_me_d = node.get();

            ((*mut_me_d).val).Iterate(
                _yield,
                &mut NodeIteration::EQUALS_QUALITATIVE(*mut_me_b),
                0,
                0,
            );
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_val(child) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 48;
    }

    fn GetType(&self) -> u32 {
        return 48;
    }
}

#[derive(Debug, Clone)]
pub struct GREATERTHAN {
    pub val: f64, /* F64 */
}

impl GREATERTHAN {
    fn new(tok: Token, _val: f64) -> Box<Self> {
        Box::new(GREATERTHAN { val: _val })
    }
}

impl<'a> ASTNodeTraits<'a> for GREATERTHAN
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::GREATERTHAN(*mut_me), parent, 50, i, j) {
                return;
            };
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 50;
    }

    fn GetType(&self) -> u32 {
        return 50;
    }
}

#[derive(Debug, Clone)]
pub struct LESSTHAN {
    pub val: f64, /* F64 */
}

impl LESSTHAN {
    fn new(tok: Token, _val: f64) -> Box<Self> {
        Box::new(LESSTHAN { val: _val })
    }
}

impl<'a> ASTNodeTraits<'a> for LESSTHAN
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::LESSTHAN(*mut_me), parent, 52, i, j) {
                return;
            };
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 52;
    }

    fn GetType(&self) -> u32 {
        return 52;
    }
}

#[derive(Debug, Clone)]
pub struct RANGE {
    pub left: f64,  /* F64 */
    pub right: f64, /* F64 */
}

impl RANGE {
    fn new(tok: Token, _left: f64, _right: f64) -> Box<Self> {
        Box::new(RANGE {
            left: _left,
            right: _right,
        })
    }
}

impl<'a> ASTNodeTraits<'a> for RANGE
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::RANGE(*mut_me), parent, 54, i, j) {
                return;
            };
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 54;
    }

    fn GetType(&self) -> u32 {
        return 54;
    }
}

#[derive(Debug, Clone)]
pub struct DATE {
    pub from: String, /* STRING */
    pub to: String,   /* STRING */
}

impl DATE {
    fn new(tok: Token, _from: String, _to: String) -> Box<Self> {
        Box::new(DATE {
            from: _from,
            to: _to,
        })
    }
}

impl<'a> ASTNodeTraits<'a> for DATE
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::DATE(*mut_me), parent, 56, i, j) {
                return;
            };
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 56;
    }

    fn GetType(&self) -> u32 {
        return 56;
    }
}

#[derive(Debug, Clone)]
pub struct ORDER {
    pub val: f64, /* F64 */
}

impl ORDER {
    fn new(tok: Token, _val: f64) -> Box<Self> {
        Box::new(ORDER { val: _val })
    }
}

impl<'a> ASTNodeTraits<'a> for ORDER
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::ORDER(*mut_me), parent, 58, i, j) {
                return;
            };
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 58;
    }

    fn GetType(&self) -> u32 {
        return 58;
    }
}

#[derive(Debug, Clone)]
pub struct IDENTIFIER {
    pub ids: String, /* STRING | STRING */
}

impl IDENTIFIER {
    fn new(tok: Token, _ids: String) -> Box<Self> {
        Box::new(IDENTIFIER { ids: _ids })
    }
}

impl<'a> ASTNodeTraits<'a> for IDENTIFIER
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::IDENTIFIER(*mut_me), parent, 60, i, j) {
                return;
            };
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 60;
    }

    fn GetType(&self) -> u32 {
        return 60;
    }
}

#[derive(Debug, Clone)]
pub struct PathPart {
    pub ids: Vec<ASTNode>, /* VECTOR */
    pub dividers: i32,     /* I32 */
}

impl PathPart {
    fn new(tok: Token, _ids: Vec<ASTNode>, _dividers: i32) -> Box<Self> {
        Box::new(PathPart {
            ids: _ids,
            dividers: _dividers,
        })
    }

    fn replace_ids(&mut self, child: ASTNode, index: i32) -> Option<ASTNode> {
        match &child {
            ASTNode::WildCard(_) | ASTNode::TextFrag(_) => {
                if index as usize >= self.ids.len() {
                    self.ids.push(child);
                    None
                } else {
                    self.ids.push(child);
                    let node = self.ids.swap_remove(index as usize);
                    Some(node)
                }
            }
            ASTNode::NONE => {
                if (index as usize) < self.ids.len() {
                    let node = self.ids.remove(index as usize);
                    Some(node)
                } else {
                    None
                }
            }
            _ => None,
        }
    }
}

impl<'a> ASTNodeTraits<'a> for PathPart
where
    Self: Sized,
{
    fn Iterate(
        &'a mut self,
        _yield: &mut impl FnMut(&mut NodeIteration<'a>, &mut NodeIteration<'a>, u32, i32, i32) -> bool,
        parent: &mut NodeIteration<'a>,
        i: i32,
        j: i32,
    ) {
        let node = UnsafeCell::from(self);

        unsafe {
            let mut_me = node.get();

            if !_yield(&mut NodeIteration::PathPart(*mut_me), parent, 62, i, j) {
                return;
            };
        }

        unsafe {
            let mut_me_a = node.get();
            for j in 0..(*mut_me_a).ids.len() {
                let mut_me_b = node.get();
                let child = &mut (*mut_me_b).ids[j];

                match child {
                    ASTNode::WildCard(child) => {
                        unsafe {
                            let mut_me = node.get();
                            child.Iterate(
                                _yield,
                                &mut NodeIteration::PathPart(*mut_me),
                                0,
                                j as i32,
                            )
                        };
                    }

                    ASTNode::TextFrag(child) => {
                        unsafe {
                            let mut_me = node.get();
                            child.Iterate(
                                _yield,
                                &mut NodeIteration::PathPart(*mut_me),
                                0,
                                j as i32,
                            )
                        };
                    }
                    _ => {}
                }
            }
        }
    }

    fn Replace(&mut self, child: ASTNode, i: i32, j: i32) -> ASTNode {
        match i {
            0 => {
                if let Some(old) = self.replace_ids(child, j) {
                    return old;
                } else {
                    return ASTNode::NONE;
                }
            }
            _ => {}
        };

        ASTNode::NONE
    }

    fn Token(&self) -> Token {
        Token::empty()
    }

    fn Type() -> u32 {
        return 62;
    }

    fn GetType(&self) -> u32 {
        return 62;
    }
}

/**
```
{ t_QueryBody, container:$1, filter:$2, sort:$3 }
```*/
fn _fn0(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::NODE(r_0) = v0 {
        if let ASTNode::ContainerClause(r_1) = r_0 {
            if let HCO::NODE(r_2) = v1 {
                if let HCO::NODES(mut r_3) = v2 {
                    let mut ref_0 = ASTNode::QueryBody(QueryBody::new(tok, Some(r_1), r_2, r_3));
                    args.push(HCO::NODE(ref_0))
                }
            }
        }
    }
}
/**
```
{ t_QueryBody, container:$NULL, filter:$1, sort:$2 }
```*/
fn _fn1(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v0 {
        if let HCO::NODES(mut r_1) = v1 {
            let mut ref_0 = ASTNode::QueryBody(QueryBody::new(tok, None, r_0, r_1));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_QueryBody, container:$1, filter:$NULL, sort:$2 }
```*/
fn _fn2(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v0 {
        if let ASTNode::ContainerClause(r_1) = r_0 {
            if let HCO::NODES(mut r_2) = v1 {
                let mut ref_0 =
                    ASTNode::QueryBody(QueryBody::new(tok, Some(r_1), ASTNode::NONE, r_2));
                args.push(HCO::NODE(ref_0))
            }
        }
    }
}
/**
```
{ t_QueryBody, container:$1, filter:$2, sort:$NULL }
```*/
fn _fn3(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v0 {
        if let ASTNode::ContainerClause(r_1) = r_0 {
            if let HCO::NODE(r_2) = v1 {
                let mut ref_0 = ASTNode::QueryBody(QueryBody::new(tok, Some(r_1), r_2, Vec::new()));
                args.push(HCO::NODE(ref_0))
            }
        }
    }
}
/**
```
{ t_QueryBody, container:$NULL, filter:$NULL, sort:$1 }
```*/
fn _fn4(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    if let HCO::NODES(mut r_0) = v0 {
        let mut ref_0 = ASTNode::QueryBody(QueryBody::new(tok, None, ASTNode::NONE, r_0));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_QueryBody, container:$NULL, filter:$1, sort:$NULL }
```*/
fn _fn5(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    if let HCO::NODE(r_0) = v0 {
        let mut ref_0 = ASTNode::QueryBody(QueryBody::new(tok, None, r_0, Vec::new()));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_QueryBody, container:$1, filter:$NULL, sort:$NULL }
```*/
fn _fn6(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    if let HCO::NODE(r_0) = v0 {
        if let ASTNode::ContainerClause(r_1) = r_0 {
            let mut ref_0 =
                ASTNode::QueryBody(QueryBody::new(tok, Some(r_1), ASTNode::NONE, Vec::new()));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_ContainerClause, path:$1, PATH_ONLY:bool($2) }
```*/
fn _fn7(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    if let HCO::NODES(mut r_0) = v0 {
        let mut ref_0 =
            ASTNode::ContainerClause(ContainerClause::new(tok, r_0, /* AAA */ false));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_TextFrag, val:$1 }
```*/
fn _fn8(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    let mut ref_0 = ASTNode::TextFrag(TextFrag::new(tok, /* AAA */ v0.String()));
    args.push(HCO::NODE(ref_0))
}
/**
```
{ t_TextFrag, val:$NULL }
```*/
fn _fn9(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    let mut ref_0 = ASTNode::TextFrag(TextFrag::new(tok, String::from("")));
    args.push(HCO::NODE(ref_0))
}
/**
```
{ t_WildCard }
```*/
fn _fn10(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    let mut ref_0 = ASTNode::WildCard(WildCard::new(tok));
    args.push(HCO::NODE(ref_0))
}
/**
```
{ t_AND, left:$1, right:$3 }
```*/
fn _fn11(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::NODE(r_0) = v0 {
        if let HCO::NODE(r_1) = v2 {
            let mut ref_0 = ASTNode::AND(AND::new(tok, r_0, r_1));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_OR, left:$1, right:$3 }
```*/
fn _fn12(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::NODE(r_0) = v0 {
        if let HCO::NODE(r_1) = v2 {
            let mut ref_0 = ASTNode::OR(OR::new(tok, r_0, r_1));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_NOT, left:$2 }
```*/
fn _fn13(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v1 {
        let mut ref_0 = ASTNode::NOT(NOT::new(tok, r_0));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_MATCH, value:str($1) }
```*/
fn _fn14(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    let mut ref_0 = ASTNode::MATCH(MATCH::new(tok, /* AAA */ v0.String()));
    args.push(HCO::NODE(ref_0))
}
/**
```
{ t_MATCH, value:str($1) }
```*/
fn _fn15(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    if let HCO::TOKEN(r_0) = v0 {
        let mut ref_0 = ASTNode::MATCH(MATCH::new(tok, /* AAA */ r_0.String()));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_CREATED, val:$2, order:$3 }
```*/
fn _fn16(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::NODE(r_0) = v1 {
        if let HCO::NODE(r_1) = v2 {
            if let ASTNode::ORDER(r_2) = r_1 {
                let mut ref_0 = ASTNode::CREATED(CREATED::new(tok, r_0, Some(r_2)));
                args.push(HCO::NODE(ref_0))
            }
        }
    }
}
/**
```
{ t_CREATED, val:$NULL, order:$2 }
```*/
fn _fn17(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v1 {
        if let ASTNode::ORDER(r_1) = r_0 {
            let mut ref_0 = ASTNode::CREATED(CREATED::new(tok, ASTNode::NONE, Some(r_1)));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_CREATED, val:$2, order:$NULL }
```*/
fn _fn18(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v1 {
        let mut ref_0 = ASTNode::CREATED(CREATED::new(tok, r_0, None));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_CREATED, val:$NULL, order:$NULL }
```*/
fn _fn19(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    let mut ref_0 = ASTNode::CREATED(CREATED::new(tok, ASTNode::NONE, None));
    args.push(HCO::NODE(ref_0))
}
/**
```
{ t_MODIFIED, val:$2, order:$3 }
```*/
fn _fn20(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::NODE(r_0) = v1 {
        if let HCO::NODE(r_1) = v2 {
            if let ASTNode::ORDER(r_2) = r_1 {
                let mut ref_0 = ASTNode::MODIFIED(MODIFIED::new(tok, r_0, Some(r_2)));
                args.push(HCO::NODE(ref_0))
            }
        }
    }
}
/**
```
{ t_MODIFIED, val:$NULL, order:$2 }
```*/
fn _fn21(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v1 {
        if let ASTNode::ORDER(r_1) = r_0 {
            let mut ref_0 = ASTNode::MODIFIED(MODIFIED::new(tok, ASTNode::NONE, Some(r_1)));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_MODIFIED, val:$2, order:$NULL }
```*/
fn _fn22(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v1 {
        let mut ref_0 = ASTNode::MODIFIED(MODIFIED::new(tok, r_0, None));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_MODIFIED, val:$NULL, order:$NULL }
```*/
fn _fn23(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    let mut ref_0 = ASTNode::MODIFIED(MODIFIED::new(tok, ASTNode::NONE, None));
    args.push(HCO::NODE(ref_0))
}
/**
```
{ t_SIZE, val:$2, order:$3 }
```*/
fn _fn24(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::NODE(r_0) = v1 {
        if let HCO::NODE(r_1) = v2 {
            if let ASTNode::ORDER(r_2) = r_1 {
                let mut ref_0 = ASTNode::SIZE(SIZE::new(tok, r_0, Some(r_2)));
                args.push(HCO::NODE(ref_0))
            }
        }
    }
}
/**
```
{ t_SIZE, val:$2, order:$NULL }
```*/
fn _fn25(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v1 {
        let mut ref_0 = ASTNode::SIZE(SIZE::new(tok, r_0, None));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_TAG, id:$2, val:$3, order:$4 }
```*/
fn _fn26(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v3 = args.remove(i - 0);
    let mut v2 = args.remove(i - 1);
    let mut v1 = args.remove(i - 2);
    let mut v0 = args.remove(i - 3);
    if let HCO::NODE(r_0) = v1 {
        if let ASTNode::IDENTIFIER(r_1) = r_0 {
            if let HCO::NODE(r_2) = v2 {
                if let HCO::NODE(r_3) = v3 {
                    if let ASTNode::ORDER(r_4) = r_3 {
                        let mut ref_0 = ASTNode::TAG(TAG::new(tok, r_1, r_2, Some(r_4)));
                        args.push(HCO::NODE(ref_0))
                    }
                }
            }
        }
    }
}
/**
```
{ t_TAG, id:$2, val:$NULL, order:$3 }
```*/
fn _fn27(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::NODE(r_0) = v1 {
        if let ASTNode::IDENTIFIER(r_1) = r_0 {
            if let HCO::NODE(r_2) = v2 {
                if let ASTNode::ORDER(r_3) = r_2 {
                    let mut ref_0 = ASTNode::TAG(TAG::new(tok, r_1, ASTNode::NONE, Some(r_3)));
                    args.push(HCO::NODE(ref_0))
                }
            }
        }
    }
}
/**
```
{ t_TAG, id:$2, val:$3, order:$NULL }
```*/
fn _fn28(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::NODE(r_0) = v1 {
        if let ASTNode::IDENTIFIER(r_1) = r_0 {
            if let HCO::NODE(r_2) = v2 {
                let mut ref_0 = ASTNode::TAG(TAG::new(tok, r_1, r_2, None));
                args.push(HCO::NODE(ref_0))
            }
        }
    }
}
/**
```
{ t_TAG, id:$2, val:$NULL, order:$NULL }
```*/
fn _fn29(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v1 {
        if let ASTNode::IDENTIFIER(r_1) = r_0 {
            let mut ref_0 = ASTNode::TAG(TAG::new(tok, r_1, ASTNode::NONE, None));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_EQUALS_QUANTITATIVE, val:f64($3) }
```*/
fn _fn30(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::TOKEN(r_0) = v2 {
        let mut ref_0 = ASTNode::EQUALS_QUANTITATIVE(EQUALS_QUANTITATIVE::new(
            tok,
            /* AAA */ r_0.to_f64(),
        ));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_EQUALS_QUALITATIVE, val:$3 }
```*/
fn _fn31(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::NODE(r_0) = v2 {
        if let ASTNode::IDENTIFIER(r_1) = r_0 {
            let mut ref_0 = ASTNode::EQUALS_QUALITATIVE(EQUALS_QUALITATIVE::new(tok, r_1));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_GREATERTHAN, val:f64($2) }
```*/
fn _fn32(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::TOKEN(r_0) = v1 {
        let mut ref_0 = ASTNode::GREATERTHAN(GREATERTHAN::new(tok, /* AAA */ r_0.to_f64()));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_LESSTHAN, val:f64($2) }
```*/
fn _fn33(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::TOKEN(r_0) = v1 {
        let mut ref_0 = ASTNode::LESSTHAN(LESSTHAN::new(tok, /* AAA */ r_0.to_f64()));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_EQUALS_QUANTITATIVE, val:f64($2) }
```*/
fn _fn34(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::TOKEN(r_0) = v1 {
        let mut ref_0 = ASTNode::EQUALS_QUANTITATIVE(EQUALS_QUANTITATIVE::new(
            tok,
            /* AAA */ r_0.to_f64(),
        ));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_EQUALS_QUALITATIVE, val:$2 }
```*/
fn _fn35(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v1 {
        if let ASTNode::IDENTIFIER(r_1) = r_0 {
            let mut ref_0 = ASTNode::EQUALS_QUALITATIVE(EQUALS_QUALITATIVE::new(tok, r_1));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_GREATERTHAN, val:f64($4) }
```*/
fn _fn36(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v3 = args.remove(i - 0);
    let mut v2 = args.remove(i - 1);
    let mut v1 = args.remove(i - 2);
    let mut v0 = args.remove(i - 3);
    if let HCO::TOKEN(r_0) = v3 {
        let mut ref_0 = ASTNode::GREATERTHAN(GREATERTHAN::new(tok, /* AAA */ r_0.to_f64()));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_LESSTHAN, val:f64($4) }
```*/
fn _fn37(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v3 = args.remove(i - 0);
    let mut v2 = args.remove(i - 1);
    let mut v1 = args.remove(i - 2);
    let mut v0 = args.remove(i - 3);
    if let HCO::TOKEN(r_0) = v3 {
        let mut ref_0 = ASTNode::LESSTHAN(LESSTHAN::new(tok, /* AAA */ r_0.to_f64()));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_GREATERTHAN, val:f64($3) }
```*/
fn _fn38(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::TOKEN(r_0) = v2 {
        let mut ref_0 = ASTNode::GREATERTHAN(GREATERTHAN::new(tok, /* AAA */ r_0.to_f64()));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_LESSTHAN, val:f64($3) }
```*/
fn _fn39(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::TOKEN(r_0) = v2 {
        let mut ref_0 = ASTNode::LESSTHAN(LESSTHAN::new(tok, /* AAA */ r_0.to_f64()));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_RANGE, left:f64($1), right:f64($2) }
```*/
fn _fn40(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::TOKEN(r_0) = v0 {
        if let HCO::TOKEN(r_1) = v1 {
            let mut ref_0 = ASTNode::RANGE(RANGE::new(
                tok,
                /* AAA */ r_0.to_f64(),
                /* AAA */ r_1.to_f64(),
            ));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_RANGE, left:f64($1), right:f64($2) }
```*/
fn _fn41(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::TOKEN(r_0) = v0 {
        if let HCO::TOKEN(r_1) = v1 {
            let mut ref_0 = ASTNode::RANGE(RANGE::new(
                tok,
                /* AAA */ r_0.to_f64(),
                /* AAA */ r_1.to_f64(),
            ));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_DATE, from:str($2), to:str($3) }
```*/
fn _fn42(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::TOKEN(r_0) = v1 {
        let mut ref_0 = ASTNode::DATE(DATE::new(
            tok,
            /* AAA */ r_0.String(),
            /* AAA */ v2.String(),
        ));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_DATE, from:str($2), to:str($3) }
```*/
fn _fn43(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    let mut ref_0 = ASTNode::DATE(DATE::new(
        tok,
        /* AAA */ v1.String(),
        /* AAA */ v2.String(),
    ));
    args.push(HCO::NODE(ref_0))
}
/**
```
{ t_DATE, from:str($2), to:str($NULL) }
```*/
fn _fn44(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::TOKEN(r_0) = v1 {
        let mut ref_0 = ASTNode::DATE(DATE::new(
            tok,
            /* AAA */ r_0.String(),
            /* AAA */ "".to_string(),
        ));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
{ t_DATE, from:str($2), to:str($NULL) }
```*/
fn _fn45(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    let mut ref_0 = ASTNode::DATE(DATE::new(
        tok,
        /* AAA */ v1.String(),
        /* AAA */ "".to_string(),
    ));
    args.push(HCO::NODE(ref_0))
}
/**
```
{ t_ORDER, val:f64(-1) }
```*/
fn _fn46(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    let mut ref_0 = ASTNode::ORDER(ORDER::new(tok, /* AAA */ 1.0));
    args.push(HCO::NODE(ref_0))
}
/**
```
{ t_IDENTIFIER, ids:$1 }
```*/
fn _fn47(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    let mut ref_0 = ASTNode::IDENTIFIER(IDENTIFIER::new(tok, /* AAA */ v0.String()));
    args.push(HCO::NODE(ref_0))
}
/**
```
{ t_PathPart, ids:$1, dividers:i32($2) }
```*/
fn _fn48(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODES(mut r_0) = v0 {
        if let HCO::TOKENS(mut r_1) = v1 {
            let mut ref_0 =
                ASTNode::PathPart(PathPart::new(tok, r_0, /* AAA */ (r_1.len() as i32)));
            args.push(HCO::NODE(ref_0))
        }
    }
}
/**
```
{ t_PathPart, ids:$1, dividers:i32($NULL) }
```*/
fn _fn49(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    if let HCO::NODES(mut r_0) = v0 {
        let mut ref_0 = ASTNode::PathPart(PathPart::new(tok, r_0, /* AAA */ 0i32));
        args.push(HCO::NODE(ref_0))
    }
}
/**
```
[$1]
```*/
fn _fn50(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);

    let mut ref_0: Vec<ASTNode> = Vec::new();
    if let HCO::NODE(r_0) = v0 {
        ref_0.push(r_0);

        args.push(HCO::NODES(ref_0));
    }
}
/**
```
$__first__+$__last__
```*/
fn _fn51(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);

    if let HCO::NODES(mut r_0) = v0 {
        if let HCO::NODE(r_1) = v1 {
            r_0.push(r_1);

            args.push(HCO::NODES(r_0));
        }
    }
}
/**
```
$2
```*/
fn _fn52(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::NODE(r_0) = v1 {
        args.push(HCO::NODE(r_0))
    }
}
/**
```
$2
```*/
fn _fn53(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    if let HCO::NODE(r_0) = v1 {
        args.push(HCO::NODE(r_0))
    }
}
/**
```
$2
```*/
fn _fn54(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);
    args.push(HCO::STRING(v1.String()))
}
/**
```
str($1)+str($2)
```*/
fn _fn55(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    args.push(HCO::STRING(v0.String() + &v1.String()))
}
/**
```
str($1)+str($NULL)
```*/
fn _fn56(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    args.push(HCO::STRING(v0.String() + &"".to_string()))
}
/**
```
str($1)
```*/
fn _fn57(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);
    args.push(HCO::STRING(v0.String()))
}
/**
```
$__first__+$__last__
```*/
fn _fn58(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v2 = args.remove(i - 0);
    let mut v1 = args.remove(i - 1);
    let mut v0 = args.remove(i - 2);

    if let HCO::NODES(mut r_0) = v0 {
        if let HCO::NODE(r_1) = v2 {
            r_0.push(r_1);

            args.push(HCO::NODES(r_0));
        }
    }
}
/**
```
$2
```*/
fn _fn59(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    if let HCO::TOKEN(r_0) = v1 {
        args.push(HCO::TOKEN(r_0))
    }
}
/**
```
$2
```*/
fn _fn60(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    args.push(HCO::STRING(v1.String()))
}
/**
```
[$1]
```*/
fn _fn61(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v0 = args.remove(i - 0);

    let mut ref_0: Vec<Token> = Vec::new();
    if let HCO::TOKEN(r_0) = v0 {
        ref_0.push(r_0);

        args.push(HCO::TOKENS(ref_0));
    }
}
/**
```
$__first__+$__last__
```*/
fn _fn62(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);

    if let HCO::TOKENS(mut r_0) = v0 {
        if let HCO::TOKEN(r_1) = v1 {
            r_0.push(r_1);

            args.push(HCO::TOKENS(r_0));
        }
    }
}
/**
```

```*/
fn _fn63(args: &mut Vec<HCO>, tok: Token) {}
/**
```

```*/
fn _fn64(args: &mut Vec<HCO>, tok: Token) {
    let mut i = args.len() - 1;
    let mut v1 = args.remove(i - 0);
    let mut v0 = args.remove(i - 1);
    args.push(v1);
}

pub const FunctionMaps: [RF; 160] = [
    _fn63, _fn63, _fn0, _fn1, _fn2, _fn3, _fn4, _fn5, _fn6, _fn7, _fn50, _fn51, _fn63, _fn63, _fn8,
    _fn9, _fn10, _fn63, _fn63, _fn64, _fn63, _fn63, _fn63, _fn63, _fn63, _fn63, _fn52, _fn63,
    _fn11, _fn11, _fn11, _fn11, _fn63, _fn12, _fn12, _fn12, _fn12, _fn63, _fn13, _fn13, _fn13,
    _fn13, _fn53, _fn14, _fn15, _fn63, _fn64, _fn63, _fn63, _fn63, _fn63, _fn16, _fn16, _fn17,
    _fn18, _fn17, _fn18, _fn19, _fn19, _fn20, _fn20, _fn21, _fn22, _fn21, _fn22, _fn23, _fn23,
    _fn24, _fn24, _fn25, _fn25, _fn26, _fn27, _fn28, _fn29, _fn30, _fn31, _fn32, _fn33, _fn64,
    _fn64, _fn34, _fn34, _fn34, _fn35, _fn35, _fn35, _fn36, _fn32, _fn37, _fn33, _fn63, _fn63,
    _fn38, _fn39, _fn40, _fn41, _fn42, _fn42, _fn43, _fn44, _fn43, _fn44, _fn45, _fn45, _fn46,
    _fn46, _fn46, _fn46, _fn46, _fn46, _fn46, _fn46, _fn46, _fn46, _fn46, _fn46, _fn47, _fn63,
    _fn63, _fn54, _fn54, _fn55, _fn56, _fn63, _fn63, _fn63, _fn63, _fn64, _fn63, _fn63, _fn63,
    _fn53, _fn50, _fn51, _fn57, _fn55, _fn50, _fn58, _fn59, _fn59, _fn59, _fn59, _fn59, _fn59,
    _fn59, _fn59, _fn59, _fn60, _fn60, _fn60, _fn60, _fn57, _fn55, _fn57, _fn55, _fn48, _fn49,
    _fn61, _fn62,
];
