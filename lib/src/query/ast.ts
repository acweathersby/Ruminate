
/* **** DO NOT MODIFY **** DO NOT MODIFY **** DO NOT MODIFY ****
 * 
 * This code has been automatically generated by Hydrocarbon Toolkit
 * 
 * ###################################################################
 * 
 * Copyright 2022 Anthony C. Weathersby
 * 
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 */


import {
    ASTNode,
    ByteReader,
    ByteWriter,
    Token,
    Deserialize as InternalDeserialize,
    SerializeType,
    SerializeVector,
    SerializeStructVector
} from "@hctoolkit/runtime";


export enum ASTType {
QueryBody = 22,
ContainerClause = 24,
TextFrag = 26,
WildCard = 28,
AND = 30,
OR = 32,
NOT = 34,
MATCH = 36,
CREATED = 38,
MODIFIED = 40,
SIZE = 42,
TAG = 44,
EQUALS_QUANTITATIVE = 46,
EQUALS_QUALITATIVE = 48,
GREATERTHAN = 50,
LESSTHAN = 52,
RANGE = 54,
DATE = 56,
ORDER = 58,
IDENTIFIER = 60,
PathPart = 62
}



export function Deserialize(reader: ByteReader){
    return InternalDeserialize(reader, DeserializeStruct)
}

function DeserializeStruct(reader: ByteReader): ASTNode<ASTType>{
    switch(reader.peek_byte()){
        
        case 1: return QueryBody.Deserialize(reader);
        case 1: return ContainerClause.Deserialize(reader);
        case 1: return TextFrag.Deserialize(reader);
        case 1: return WildCard.Deserialize(reader);
        case 1: return AND.Deserialize(reader);
        case 1: return OR.Deserialize(reader);
        case 1: return NOT.Deserialize(reader);
        case 1: return MATCH.Deserialize(reader);
        case 1: return CREATED.Deserialize(reader);
        case 1: return MODIFIED.Deserialize(reader);
        case 1: return SIZE.Deserialize(reader);
        case 1: return TAG.Deserialize(reader);
        case 1: return EQUALS_QUANTITATIVE.Deserialize(reader);
        case 1: return EQUALS_QUALITATIVE.Deserialize(reader);
        case 1: return GREATERTHAN.Deserialize(reader);
        case 1: return LESSTHAN.Deserialize(reader);
        case 1: return RANGE.Deserialize(reader);
        case 1: return DATE.Deserialize(reader);
        case 1: return ORDER.Deserialize(reader);
        case 1: return IDENTIFIER.Deserialize(reader);
        case 1: return PathPart.Deserialize(reader);
    }
    throw new Error("Could not deserialize");
}


export class QueryBody extends ASTNode<ASTType> {
    
    container:ContainerClause| null;
filter:(AND | OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG)| null;
sort:(CREATED | MODIFIED | SIZE | TAG)[];

    constructor(
        _container:ContainerClause| null,
        _filter:(AND | OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG)| null,
        _sort:(CREATED | MODIFIED | SIZE | TAG)[],) 
    {
        super();
            this.container = _container;
        this.filter = _filter;
        this.sort = _sort;
        
    }
    replace_container(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.container;           

            this.container = null;
            
            return old;
        }
                     else 
        if(ContainerClause.nodeIs(child)){
            
            let old = this.container;           

            this.container = child;
            
            return old;
        }
        return null;
    }

    replace_filter(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.filter;           

            this.filter = null;
            
            return old;
        }
                     else 
        if(AND.nodeIs(child)
    || OR.nodeIs(child)
    || NOT.nodeIs(child)
    || MATCH.nodeIs(child)
    || CREATED.nodeIs(child)
    || MODIFIED.nodeIs(child)
    || SIZE.nodeIs(child)
    || TAG.nodeIs(child)){
            
            let old = this.filter;           

            this.filter = child;
            
            return old;
        }
        return null;
    }

    replace_sort(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.sort.length && j >= 0){
                return this.sort.splice(j, 1)[0];
            }
        }else if(CREATED.nodeIs(child)
    || MODIFIED.nodeIs(child)
    || SIZE.nodeIs(child)
    || TAG.nodeIs(child)){
            if(j < 0){
                this.sort.unshift(child);
            }else if(j >= this.sort.length){
                this.sort.push(child);
            }else {
                return this.sort.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.container instanceof ASTNode)
            this.container.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        if(this.filter instanceof ASTNode)
            this.filter.$$____Iterate_$_$_$( _yield, this, 1, 0);
    
        for(let i = 0; i < this.sort.length; i++){
            this.sort[i].$$____Iterate_$_$_$(_yield, this, 2, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_container(child);
    case 1: return this.replace_filter(child);
    case 2: return this.replace_sort(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is QueryBody {
        if(typeof s == "object")
            return s instanceof QueryBody;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is QueryBody {
        return s.type == ASTType.QueryBody;
    }

    static Type(): ASTType.QueryBody {
        return ASTType.QueryBody;
    }

    get type(): ASTType.QueryBody {
        return ASTType.QueryBody;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        if(!this._container)
            writer.write_null();
        else 
            this._container.serialize(writer);
        

        if(!this._filter)
            writer.write_null();
        else 
            this._filter.serialize(writer);
        

        SerializeStructVector(this._sort, writer)
    }

    static Deserialize(reader:ByteReader): QueryBody {

        reader.assert_byte(1);

        
        var _container = reader.assert_null() ? null : ContainerClause.Deserialize(reader);

        var _filter = reader.assert_null() ? null : Deserialize(reader)

        var _sort = Deserialize(reader);

        return new QueryBody(container, filter, sort);
    }
}



export class ContainerClause extends ASTNode<ASTType> {
    
    path:PathPart[];
PATH_ONLY:boolean;

    constructor(
        _path:PathPart[],
        _PATH_ONLY:boolean,) 
    {
        super();
            this.path = _path;
        this.PATH_ONLY = _PATH_ONLY;
        
    }
    replace_path(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.path.length && j >= 0){
                return this.path.splice(j, 1)[0];
            }
        }else if(PathPart.nodeIs(child)){
            if(j < 0){
                this.path.unshift(child);
            }else if(j >= this.path.length){
                this.path.push(child);
            }else {
                return this.path.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.path.length; i++){
            this.path[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_path(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is ContainerClause {
        if(typeof s == "object")
            return s instanceof ContainerClause;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is ContainerClause {
        return s.type == ASTType.ContainerClause;
    }

    static Type(): ASTType.ContainerClause {
        return ASTType.ContainerClause;
    }

    get type(): ASTType.ContainerClause {
        return ASTType.ContainerClause;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        SerializeStructVector(this._path, writer)
           writer.write_byte(this._PATH_ONLY ==  true ? 1 : 0)
    }

    static Deserialize(reader:ByteReader): ContainerClause {

        reader.assert_byte(1);

        
        var _path = Deserialize(reader);
           var _PATH_ONLY = !!reader.read_byte()

        return new ContainerClause(path, PATH_ONLY);
    }
}



export class TextFrag extends ASTNode<ASTType> {
    
    val:string| null;

    constructor(
        _val:string| null,) 
    {
        super();
            this.val = _val;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is TextFrag {
        if(typeof s == "object")
            return s instanceof TextFrag;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is TextFrag {
        return s.type == ASTType.TextFrag;
    }

    static Type(): ASTType.TextFrag {
        return ASTType.TextFrag;
    }

    get type(): ASTType.TextFrag {
        return ASTType.TextFrag;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
                 writer.write_string(this._val)
    }

    static Deserialize(reader:ByteReader): TextFrag {

        reader.assert_byte(1);

                 var _val = reader.read_string()

        return new TextFrag(val);
    }
}



export class WildCard extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is WildCard {
        if(typeof s == "object")
            return s instanceof WildCard;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is WildCard {
        return s.type == ASTType.WildCard;
    }

    static Type(): ASTType.WildCard {
        return ASTType.WildCard;
    }

    get type(): ASTType.WildCard {
        return ASTType.WildCard;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
    }

    static Deserialize(reader:ByteReader): WildCard {

        reader.assert_byte(1);

        

        return new WildCard();
    }
}



export class AND extends ASTNode<ASTType> {
    
    left:(OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG);
right:(AND | OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG);

    constructor(
        _left:(OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG),
        _right:(AND | OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG),) 
    {
        super();
            this.left = _left;
        this.right = _right;
        
    }
    replace_left(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(OR.nodeIs(child)
    || NOT.nodeIs(child)
    || MATCH.nodeIs(child)
    || CREATED.nodeIs(child)
    || MODIFIED.nodeIs(child)
    || SIZE.nodeIs(child)
    || TAG.nodeIs(child)){
            
            let old = this.left;           

            this.left = child;
            
            return old;
        }
        return null;
    }

    replace_right(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(AND.nodeIs(child)
    || OR.nodeIs(child)
    || NOT.nodeIs(child)
    || MATCH.nodeIs(child)
    || CREATED.nodeIs(child)
    || MODIFIED.nodeIs(child)
    || SIZE.nodeIs(child)
    || TAG.nodeIs(child)){
            
            let old = this.right;           

            this.right = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.left.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        this.right.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_left(child);
    case 1: return this.replace_right(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is AND {
        if(typeof s == "object")
            return s instanceof AND;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is AND {
        return s.type == ASTType.AND;
    }

    static Type(): ASTType.AND {
        return ASTType.AND;
    }

    get type(): ASTType.AND {
        return ASTType.AND;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        this._left.serialize(writer);

        this._right.serialize(writer);
    }

    static Deserialize(reader:ByteReader): AND {

        reader.assert_byte(1);

        
        var _left = Deserialize(reader)

        var _right = Deserialize(reader)

        return new AND(left, right);
    }
}



export class OR extends ASTNode<ASTType> {
    
    left:(NOT | MATCH | CREATED | MODIFIED | SIZE | TAG);
right:(OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG);

    constructor(
        _left:(NOT | MATCH | CREATED | MODIFIED | SIZE | TAG),
        _right:(OR | NOT | MATCH | CREATED | MODIFIED | SIZE | TAG),) 
    {
        super();
            this.left = _left;
        this.right = _right;
        
    }
    replace_left(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(NOT.nodeIs(child)
    || MATCH.nodeIs(child)
    || CREATED.nodeIs(child)
    || MODIFIED.nodeIs(child)
    || SIZE.nodeIs(child)
    || TAG.nodeIs(child)){
            
            let old = this.left;           

            this.left = child;
            
            return old;
        }
        return null;
    }

    replace_right(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(OR.nodeIs(child)
    || NOT.nodeIs(child)
    || MATCH.nodeIs(child)
    || CREATED.nodeIs(child)
    || MODIFIED.nodeIs(child)
    || SIZE.nodeIs(child)
    || TAG.nodeIs(child)){
            
            let old = this.right;           

            this.right = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.left.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        this.right.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_left(child);
    case 1: return this.replace_right(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is OR {
        if(typeof s == "object")
            return s instanceof OR;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is OR {
        return s.type == ASTType.OR;
    }

    static Type(): ASTType.OR {
        return ASTType.OR;
    }

    get type(): ASTType.OR {
        return ASTType.OR;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        this._left.serialize(writer);

        this._right.serialize(writer);
    }

    static Deserialize(reader:ByteReader): OR {

        reader.assert_byte(1);

        
        var _left = Deserialize(reader)

        var _right = Deserialize(reader)

        return new OR(left, right);
    }
}



export class NOT extends ASTNode<ASTType> {
    
    left:(MATCH | CREATED | MODIFIED | SIZE | TAG);

    constructor(
        _left:(MATCH | CREATED | MODIFIED | SIZE | TAG),) 
    {
        super();
            this.left = _left;
        
    }
    replace_left(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(MATCH.nodeIs(child)
    || CREATED.nodeIs(child)
    || MODIFIED.nodeIs(child)
    || SIZE.nodeIs(child)
    || TAG.nodeIs(child)){
            
            let old = this.left;           

            this.left = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.left.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_left(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is NOT {
        if(typeof s == "object")
            return s instanceof NOT;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is NOT {
        return s.type == ASTType.NOT;
    }

    static Type(): ASTType.NOT {
        return ASTType.NOT;
    }

    get type(): ASTType.NOT {
        return ASTType.NOT;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        this._left.serialize(writer);
    }

    static Deserialize(reader:ByteReader): NOT {

        reader.assert_byte(1);

        
        var _left = Deserialize(reader)

        return new NOT(left);
    }
}



export class MATCH extends ASTNode<ASTType> {
    
    value:(string | Token);

    constructor(
        _value:(string | Token),) 
    {
        super();
            this.value = _value;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is MATCH {
        if(typeof s == "object")
            return s instanceof MATCH;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is MATCH {
        return s.type == ASTType.MATCH;
    }

    static Type(): ASTType.MATCH {
        return ASTType.MATCH;
    }

    get type(): ASTType.MATCH {
        return ASTType.MATCH;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
            SerializeType(this._value, writer)
    }

    static Deserialize(reader:ByteReader): MATCH {

        reader.assert_byte(1);

        var _value = Deserialize(reader)

        return new MATCH(value);
    }
}



export class CREATED extends ASTNode<ASTType> {
    
    val:(EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE)| null;
order:ORDER| null;

    constructor(
        _val:(EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE)| null,
        _order:ORDER| null,) 
    {
        super();
            this.val = _val;
        this.order = _order;
        
    }
    replace_val(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.val;           

            this.val = null;
            
            return old;
        }
                     else 
        if(EQUALS_QUANTITATIVE.nodeIs(child)
    || EQUALS_QUALITATIVE.nodeIs(child)
    || GREATERTHAN.nodeIs(child)
    || LESSTHAN.nodeIs(child)
    || RANGE.nodeIs(child)
    || DATE.nodeIs(child)){
            
            let old = this.val;           

            this.val = child;
            
            return old;
        }
        return null;
    }

    replace_order(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.order;           

            this.order = null;
            
            return old;
        }
                     else 
        if(ORDER.nodeIs(child)){
            
            let old = this.order;           

            this.order = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.val instanceof ASTNode)
            this.val.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        if(this.order instanceof ASTNode)
            this.order.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_val(child);
    case 1: return this.replace_order(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is CREATED {
        if(typeof s == "object")
            return s instanceof CREATED;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is CREATED {
        return s.type == ASTType.CREATED;
    }

    static Type(): ASTType.CREATED {
        return ASTType.CREATED;
    }

    get type(): ASTType.CREATED {
        return ASTType.CREATED;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        if(!this._val)
            writer.write_null();
        else 
            this._val.serialize(writer);
        

        if(!this._order)
            writer.write_null();
        else 
            this._order.serialize(writer);
        
    }

    static Deserialize(reader:ByteReader): CREATED {

        reader.assert_byte(1);

        
        var _val = reader.assert_null() ? null : Deserialize(reader)

        var _order = reader.assert_null() ? null : ORDER.Deserialize(reader);

        return new CREATED(val, order);
    }
}



export class MODIFIED extends ASTNode<ASTType> {
    
    val:(EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE)| null;
order:ORDER| null;

    constructor(
        _val:(EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE)| null,
        _order:ORDER| null,) 
    {
        super();
            this.val = _val;
        this.order = _order;
        
    }
    replace_val(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.val;           

            this.val = null;
            
            return old;
        }
                     else 
        if(EQUALS_QUANTITATIVE.nodeIs(child)
    || EQUALS_QUALITATIVE.nodeIs(child)
    || GREATERTHAN.nodeIs(child)
    || LESSTHAN.nodeIs(child)
    || RANGE.nodeIs(child)
    || DATE.nodeIs(child)){
            
            let old = this.val;           

            this.val = child;
            
            return old;
        }
        return null;
    }

    replace_order(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.order;           

            this.order = null;
            
            return old;
        }
                     else 
        if(ORDER.nodeIs(child)){
            
            let old = this.order;           

            this.order = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        if(this.val instanceof ASTNode)
            this.val.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        if(this.order instanceof ASTNode)
            this.order.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_val(child);
    case 1: return this.replace_order(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is MODIFIED {
        if(typeof s == "object")
            return s instanceof MODIFIED;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is MODIFIED {
        return s.type == ASTType.MODIFIED;
    }

    static Type(): ASTType.MODIFIED {
        return ASTType.MODIFIED;
    }

    get type(): ASTType.MODIFIED {
        return ASTType.MODIFIED;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        if(!this._val)
            writer.write_null();
        else 
            this._val.serialize(writer);
        

        if(!this._order)
            writer.write_null();
        else 
            this._order.serialize(writer);
        
    }

    static Deserialize(reader:ByteReader): MODIFIED {

        reader.assert_byte(1);

        
        var _val = reader.assert_null() ? null : Deserialize(reader)

        var _order = reader.assert_null() ? null : ORDER.Deserialize(reader);

        return new MODIFIED(val, order);
    }
}



export class SIZE extends ASTNode<ASTType> {
    
    val:(EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE);
order:ORDER| null;

    constructor(
        _val:(EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE),
        _order:ORDER| null,) 
    {
        super();
            this.val = _val;
        this.order = _order;
        
    }
    replace_val(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(EQUALS_QUANTITATIVE.nodeIs(child)
    || EQUALS_QUALITATIVE.nodeIs(child)
    || GREATERTHAN.nodeIs(child)
    || LESSTHAN.nodeIs(child)
    || RANGE.nodeIs(child)
    || DATE.nodeIs(child)){
            
            let old = this.val;           

            this.val = child;
            
            return old;
        }
        return null;
    }

    replace_order(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.order;           

            this.order = null;
            
            return old;
        }
                     else 
        if(ORDER.nodeIs(child)){
            
            let old = this.order;           

            this.order = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.val.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        if(this.order instanceof ASTNode)
            this.order.$$____Iterate_$_$_$( _yield, this, 1, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_val(child);
    case 1: return this.replace_order(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is SIZE {
        if(typeof s == "object")
            return s instanceof SIZE;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is SIZE {
        return s.type == ASTType.SIZE;
    }

    static Type(): ASTType.SIZE {
        return ASTType.SIZE;
    }

    get type(): ASTType.SIZE {
        return ASTType.SIZE;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        this._val.serialize(writer);

        if(!this._order)
            writer.write_null();
        else 
            this._order.serialize(writer);
        
    }

    static Deserialize(reader:ByteReader): SIZE {

        reader.assert_byte(1);

        
        var _val = Deserialize(reader)

        var _order = reader.assert_null() ? null : ORDER.Deserialize(reader);

        return new SIZE(val, order);
    }
}



export class TAG extends ASTNode<ASTType> {
    
    id:IDENTIFIER;
val:(EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE)| null;
order:ORDER| null;

    constructor(
        _id:IDENTIFIER,
        _val:(EQUALS_QUANTITATIVE | EQUALS_QUALITATIVE | GREATERTHAN | LESSTHAN | RANGE | DATE)| null,
        _order:ORDER| null,) 
    {
        super();
            this.id = _id;
        this.val = _val;
        this.order = _order;
        
    }
    replace_id(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(IDENTIFIER.nodeIs(child)){
            
            let old = this.id;           

            this.id = child;
            
            return old;
        }
        return null;
    }

    replace_val(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.val;           

            this.val = null;
            
            return old;
        }
                     else 
        if(EQUALS_QUANTITATIVE.nodeIs(child)
    || EQUALS_QUALITATIVE.nodeIs(child)
    || GREATERTHAN.nodeIs(child)
    || LESSTHAN.nodeIs(child)
    || RANGE.nodeIs(child)
    || DATE.nodeIs(child)){
            
            let old = this.val;           

            this.val = child;
            
            return old;
        }
        return null;
    }

    replace_order(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(child === null){
            let old = this.order;           

            this.order = null;
            
            return old;
        }
                     else 
        if(ORDER.nodeIs(child)){
            
            let old = this.order;           

            this.order = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.id.$$____Iterate_$_$_$( _yield, this, 0, 0);
    
        if(this.val instanceof ASTNode)
            this.val.$$____Iterate_$_$_$( _yield, this, 1, 0);
    
        if(this.order instanceof ASTNode)
            this.order.$$____Iterate_$_$_$( _yield, this, 2, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_id(child);
    case 1: return this.replace_val(child);
    case 2: return this.replace_order(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is TAG {
        if(typeof s == "object")
            return s instanceof TAG;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is TAG {
        return s.type == ASTType.TAG;
    }

    static Type(): ASTType.TAG {
        return ASTType.TAG;
    }

    get type(): ASTType.TAG {
        return ASTType.TAG;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        this._id.serialize(writer);

        if(!this._val)
            writer.write_null();
        else 
            this._val.serialize(writer);
        

        if(!this._order)
            writer.write_null();
        else 
            this._order.serialize(writer);
        
    }

    static Deserialize(reader:ByteReader): TAG {

        reader.assert_byte(1);

        
        var _id = IDENTIFIER.Deserialize(reader);

        var _val = reader.assert_null() ? null : Deserialize(reader)

        var _order = reader.assert_null() ? null : ORDER.Deserialize(reader);

        return new TAG(id, val, order);
    }
}



export class EQUALS_QUANTITATIVE extends ASTNode<ASTType> {
    
    val:number;

    constructor(
        _val:number,) 
    {
        super();
            this.val = _val;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is EQUALS_QUANTITATIVE {
        if(typeof s == "object")
            return s instanceof EQUALS_QUANTITATIVE;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is EQUALS_QUANTITATIVE {
        return s.type == ASTType.EQUALS_QUANTITATIVE;
    }

    static Type(): ASTType.EQUALS_QUANTITATIVE {
        return ASTType.EQUALS_QUANTITATIVE;
    }

    get type(): ASTType.EQUALS_QUANTITATIVE {
        return ASTType.EQUALS_QUANTITATIVE;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
                    writer.write_double(this._val)
    }

    static Deserialize(reader:ByteReader): EQUALS_QUANTITATIVE {

        reader.assert_byte(1);

                    var _val = reader.read_double()

        return new EQUALS_QUANTITATIVE(val);
    }
}



export class EQUALS_QUALITATIVE extends ASTNode<ASTType> {
    
    val:IDENTIFIER;

    constructor(
        _val:IDENTIFIER,) 
    {
        super();
            this.val = _val;
        
    }
    replace_val(child: ASTNode<ASTType>) : null | ASTNode<ASTType> {
        
        if(IDENTIFIER.nodeIs(child)){
            
            let old = this.val;           

            this.val = child;
            
            return old;
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        this.val.$$____Iterate_$_$_$( _yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_val(child);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is EQUALS_QUALITATIVE {
        if(typeof s == "object")
            return s instanceof EQUALS_QUALITATIVE;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is EQUALS_QUALITATIVE {
        return s.type == ASTType.EQUALS_QUALITATIVE;
    }

    static Type(): ASTType.EQUALS_QUALITATIVE {
        return ASTType.EQUALS_QUALITATIVE;
    }

    get type(): ASTType.EQUALS_QUALITATIVE {
        return ASTType.EQUALS_QUALITATIVE;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        this._val.serialize(writer);
    }

    static Deserialize(reader:ByteReader): EQUALS_QUALITATIVE {

        reader.assert_byte(1);

        
        var _val = IDENTIFIER.Deserialize(reader);

        return new EQUALS_QUALITATIVE(val);
    }
}



export class GREATERTHAN extends ASTNode<ASTType> {
    
    val:number;

    constructor(
        _val:number,) 
    {
        super();
            this.val = _val;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is GREATERTHAN {
        if(typeof s == "object")
            return s instanceof GREATERTHAN;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is GREATERTHAN {
        return s.type == ASTType.GREATERTHAN;
    }

    static Type(): ASTType.GREATERTHAN {
        return ASTType.GREATERTHAN;
    }

    get type(): ASTType.GREATERTHAN {
        return ASTType.GREATERTHAN;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
                    writer.write_double(this._val)
    }

    static Deserialize(reader:ByteReader): GREATERTHAN {

        reader.assert_byte(1);

                    var _val = reader.read_double()

        return new GREATERTHAN(val);
    }
}



export class LESSTHAN extends ASTNode<ASTType> {
    
    val:number;

    constructor(
        _val:number,) 
    {
        super();
            this.val = _val;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is LESSTHAN {
        if(typeof s == "object")
            return s instanceof LESSTHAN;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is LESSTHAN {
        return s.type == ASTType.LESSTHAN;
    }

    static Type(): ASTType.LESSTHAN {
        return ASTType.LESSTHAN;
    }

    get type(): ASTType.LESSTHAN {
        return ASTType.LESSTHAN;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
                    writer.write_double(this._val)
    }

    static Deserialize(reader:ByteReader): LESSTHAN {

        reader.assert_byte(1);

                    var _val = reader.read_double()

        return new LESSTHAN(val);
    }
}



export class RANGE extends ASTNode<ASTType> {
    
    left:number;
right:number;

    constructor(
        _left:number,
        _right:number,) 
    {
        super();
            this.left = _left;
        this.right = _right;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is RANGE {
        if(typeof s == "object")
            return s instanceof RANGE;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is RANGE {
        return s.type == ASTType.RANGE;
    }

    static Type(): ASTType.RANGE {
        return ASTType.RANGE;
    }

    get type(): ASTType.RANGE {
        return ASTType.RANGE;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
                    writer.write_double(this._left)
            writer.write_double(this._right)
    }

    static Deserialize(reader:ByteReader): RANGE {

        reader.assert_byte(1);

                    var _left = reader.read_double()
            var _right = reader.read_double()

        return new RANGE(left, right);
    }
}



export class DATE extends ASTNode<ASTType> {
    
    from:string;
to:string;

    constructor(
        _from:string,
        _to:string,) 
    {
        super();
            this.from = _from;
        this.to = _to;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is DATE {
        if(typeof s == "object")
            return s instanceof DATE;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is DATE {
        return s.type == ASTType.DATE;
    }

    static Type(): ASTType.DATE {
        return ASTType.DATE;
    }

    get type(): ASTType.DATE {
        return ASTType.DATE;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
                 writer.write_string(this._from)
         writer.write_string(this._to)
    }

    static Deserialize(reader:ByteReader): DATE {

        reader.assert_byte(1);

                 var _from = reader.read_string()
         var _to = reader.read_string()

        return new DATE(from, to);
    }
}



export class ORDER extends ASTNode<ASTType> {
    
    val:number;

    constructor(
        _val:number,) 
    {
        super();
            this.val = _val;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is ORDER {
        if(typeof s == "object")
            return s instanceof ORDER;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is ORDER {
        return s.type == ASTType.ORDER;
    }

    static Type(): ASTType.ORDER {
        return ASTType.ORDER;
    }

    get type(): ASTType.ORDER {
        return ASTType.ORDER;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
                    writer.write_double(this._val)
    }

    static Deserialize(reader:ByteReader): ORDER {

        reader.assert_byte(1);

                    var _val = reader.read_double()

        return new ORDER(val);
    }
}



export class IDENTIFIER extends ASTNode<ASTType> {
    
    ids:string;

    constructor(
        _ids:string,) 
    {
        super();
            this.ids = _ids;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is IDENTIFIER {
        if(typeof s == "object")
            return s instanceof IDENTIFIER;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is IDENTIFIER {
        return s.type == ASTType.IDENTIFIER;
    }

    static Type(): ASTType.IDENTIFIER {
        return ASTType.IDENTIFIER;
    }

    get type(): ASTType.IDENTIFIER {
        return ASTType.IDENTIFIER;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
                 writer.write_string(this._ids)
    }

    static Deserialize(reader:ByteReader): IDENTIFIER {

        reader.assert_byte(1);

                 var _ids = reader.read_string()

        return new IDENTIFIER(ids);
    }
}



export class PathPart extends ASTNode<ASTType> {
    
    ids:(WildCard | TextFrag)[];
dividers:number;

    constructor(
        _ids:(WildCard | TextFrag)[],
        _dividers:number,) 
    {
        super();
            this.ids = _ids;
        this.dividers = _dividers;
        
    }
    replace_ids(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.ids.length && j >= 0){
                return this.ids.splice(j, 1)[0];
            }
        }else if(WildCard.nodeIs(child)
    || TextFrag.nodeIs(child)){
            if(j < 0){
                this.ids.unshift(child);
            }else if(j >= this.ids.length){
                this.ids.push(child);
            }else {
                return this.ids.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.ids.length; i++){
            this.ids[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_ids(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is PathPart {
        if(typeof s == "object")
            return s instanceof PathPart;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is PathPart {
        return s.type == ASTType.PathPart;
    }

    static Type(): ASTType.PathPart {
        return ASTType.PathPart;
    }

    get type(): ASTType.PathPart {
        return ASTType.PathPart;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(1);
        
        SerializeStructVector(this._ids, writer)
            writer.write_word(this._dividers)
    }

    static Deserialize(reader:ByteReader): PathPart {

        reader.assert_byte(1);

        
        var _ids = Deserialize(reader);
            var _dividers = reader.read_word()

        return new PathPart(ids, dividers);
    }
}



/**
```
{ t_QueryBody, container:$1, filter:$2, sort:$3 }
```*/
function _FN0_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:QueryBody = new QueryBody(
        v0,
        v1,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_QueryBody, container:$NULL, filter:$1, sort:$2 }
```*/
function _FN1_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:QueryBody = new QueryBody(
        null,
        v0,
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_QueryBody, container:$1, filter:$NULL, sort:$2 }
```*/
function _FN2_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:QueryBody = new QueryBody(
        v0,
        null,
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_QueryBody, container:$1, filter:$2, sort:$NULL }
```*/
function _FN3_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:QueryBody = new QueryBody(
        v0,
        v1,
        [],
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_QueryBody, container:$NULL, filter:$NULL, sort:$1 }
```*/
function _FN4_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:QueryBody = new QueryBody(
        null,
        null,
        v0,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_QueryBody, container:$NULL, filter:$1, sort:$NULL }
```*/
function _FN5_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:QueryBody = new QueryBody(
        null,
        v0,
        [],
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_QueryBody, container:$1, filter:$NULL, sort:$NULL }
```*/
function _FN6_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:QueryBody = new QueryBody(
        v0,
        null,
        [],
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_ContainerClause, path:$1, PATH_ONLY:bool($2) }
```*/
function _FN7_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:ContainerClause = new ContainerClause(
        v0,
        false,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_TextFrag, val:$1 }
```*/
function _FN8_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:TextFrag = new TextFrag(
        v0,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_TextFrag, val:$NULL }
```*/
function _FN9_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:TextFrag = new TextFrag(
        '',
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_WildCard }
```*/
function _FN10_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:WildCard = new WildCard(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_AND, left:$1, right:$3 }
```*/
function _FN11_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:AND = new AND(
        v0,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_OR, left:$1, right:$3 }
```*/
function _FN12_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:OR = new OR(
        v0,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_NOT, left:$2 }
```*/
function _FN13_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:NOT = new NOT(
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_MATCH, value:$1 }
```*/
function _FN14_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:MATCH = new MATCH(
        v0,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_CREATED, val:$2, order:$3 }
```*/
function _FN15_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:CREATED = new CREATED(
        v1,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_CREATED, val:$NULL, order:$2 }
```*/
function _FN16_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:CREATED = new CREATED(
        null,
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_CREATED, val:$2, order:$NULL }
```*/
function _FN17_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:CREATED = new CREATED(
        v1,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_CREATED, val:$NULL, order:$NULL }
```*/
function _FN18_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:CREATED = new CREATED(
        null,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_MODIFIED, val:$2, order:$3 }
```*/
function _FN19_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:MODIFIED = new MODIFIED(
        v1,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_MODIFIED, val:$NULL, order:$2 }
```*/
function _FN20_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:MODIFIED = new MODIFIED(
        null,
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_MODIFIED, val:$2, order:$NULL }
```*/
function _FN21_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:MODIFIED = new MODIFIED(
        v1,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_MODIFIED, val:$NULL, order:$NULL }
```*/
function _FN22_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:MODIFIED = new MODIFIED(
        null,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_SIZE, val:$2, order:$3 }
```*/
function _FN23_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:SIZE = new SIZE(
        v1,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_SIZE, val:$2, order:$NULL }
```*/
function _FN24_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:SIZE = new SIZE(
        v1,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_TAG, id:$2, val:$3, order:$4 }
```*/
function _FN25_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:TAG = new TAG(
        v1,
        v2,
        v3,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_TAG, id:$2, val:$NULL, order:$3 }
```*/
function _FN26_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:TAG = new TAG(
        v1,
        null,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_TAG, id:$2, val:$3, order:$NULL }
```*/
function _FN27_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:TAG = new TAG(
        v1,
        v2,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_TAG, id:$2, val:$NULL, order:$NULL }
```*/
function _FN28_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:TAG = new TAG(
        v1,
        null,
        null,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_EQUALS_QUANTITATIVE, val:f64($3) }
```*/
function _FN29_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:EQUALS_QUANTITATIVE = new EQUALS_QUANTITATIVE(
        parseFloat(v2.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_EQUALS_QUALITATIVE, val:$3 }
```*/
function _FN30_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:EQUALS_QUALITATIVE = new EQUALS_QUALITATIVE(
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_GREATERTHAN, val:f64($2) }
```*/
function _FN31_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:GREATERTHAN = new GREATERTHAN(
        parseFloat(v1.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_LESSTHAN, val:f64($2) }
```*/
function _FN32_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:LESSTHAN = new LESSTHAN(
        parseFloat(v1.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_EQUALS_QUANTITATIVE, val:f64($2) }
```*/
function _FN33_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:EQUALS_QUANTITATIVE = new EQUALS_QUANTITATIVE(
        parseFloat(v1.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_EQUALS_QUALITATIVE, val:$2 }
```*/
function _FN34_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:EQUALS_QUALITATIVE = new EQUALS_QUALITATIVE(
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_GREATERTHAN, val:f64($4) }
```*/
function _FN35_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:GREATERTHAN = new GREATERTHAN(
        parseFloat(v3.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_LESSTHAN, val:f64($4) }
```*/
function _FN36_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:LESSTHAN = new LESSTHAN(
        parseFloat(v3.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_GREATERTHAN, val:f64($3) }
```*/
function _FN37_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:GREATERTHAN = new GREATERTHAN(
        parseFloat(v2.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_LESSTHAN, val:f64($3) }
```*/
function _FN38_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:LESSTHAN = new LESSTHAN(
        parseFloat(v2.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_RANGE, left:f64($1), right:f64($2) }
```*/
function _FN39_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:RANGE = new RANGE(
        parseFloat(v0.toString()),
        parseFloat(v1.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_RANGE, left:f64($1), right:f64($2) }
```*/
function _FN40_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:RANGE = new RANGE(
        parseFloat(v0.toString()),
        parseFloat(v1.toString()),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_DATE, from:str($2), to:str($3) }
```*/
function _FN41_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:DATE = new DATE(
        v1.toString(),
        v2.toString(),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_DATE, from:str($2), to:str($3) }
```*/
function _FN42_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:DATE = new DATE(
        v1,
        v2.toString(),
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_DATE, from:str($2), to:str($NULL) }
```*/
function _FN43_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:DATE = new DATE(
        v1.toString(),
        "",
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_DATE, from:str($2), to:str($NULL) }
```*/
function _FN44_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:DATE = new DATE(
        v1,
        "",
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_ORDER, val:f64(-1) }
```*/
function _FN45_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:ORDER = new ORDER(
        1.0,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_IDENTIFIER, ids:$1 }
```*/
function _FN46_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:IDENTIFIER = new IDENTIFIER(
        v0,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_PathPart, ids:$1, dividers:i32($2) }
```*/
function _FN47_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:PathPart = new PathPart(
        v0,
        v1.length,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_PathPart, ids:$1, dividers:i32($NULL) }
```*/
function _FN48_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:PathPart = new PathPart(
        v0,
         0 ,
   );;

                                args.push(ref_0) 
                            }
/**
```
[$1]
```*/
function _FN49_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(WildCard | TextFrag)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
$__first__+$__last__
```*/
function _FN50_ (args: any[], tok: Token) : any { 
                                let v1 = args.pop();
let v0 = args.pop();
                                
v0.push(v1);
 
                                args.push(v0) } 
/**
```
$2
```*/
function _FN51_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                

                                args.push(v1) 
                            }
/**
```
$2
```*/
function _FN52_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                

                                args.push(v1) 
                            }
/**
```
str($1)+str($2)
```*/
function _FN53_ (args: any[], tok: Token) : any { let v1 = args.pop();
let v0 = args.pop(); 
 args.push(v0.toString() + v1)}
/**
```
str($1)+str($NULL)
```*/
function _FN54_ (args: any[], tok: Token) : any { let v0 = args.pop(); 
 args.push(v0.toString() + "")}
/**
```
[$1]
```*/
function _FN55_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(PathPart)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
str($1)
```*/
function _FN56_ (args: any[], tok: Token) : any { let v0 = args.pop(); 
 args.push(v0.toString())}
/**
```
str($__first__)+str($__last__)
```*/
function _FN57_ (args: any[], tok: Token) : any { let v1 = args.pop();
let v0 = args.pop(); 
 args.push(v0 + v1.toString())}
/**
```
[$1]
```*/
function _FN58_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(CREATED | MODIFIED | SIZE | TAG)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
$__first__+$__last__
```*/
function _FN59_ (args: any[], tok: Token) : any { 
                                let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
v0.push(v2);
 
                                args.push(v0) } 
/**
```
[$1]
```*/
function _FN60_ (args: any[], tok: Token) : any {
                            let v0 = args.pop(); 
                                
 let ref_0:Token[] = [v0];

                                args.push(ref_0) 
                            }
/**
```

```*/
function _FN61_ (args: any[], tok: Token) : any {}
/**
```

```*/
function _FN62_ (args: any[], tok: Token) : any {  let v1 = args.pop();
let v0 = args.pop();
 args.push(v1); }



export  const FunctionMaps = [
    _FN61_,
_FN61_,
_FN0_,
_FN1_,
_FN2_,
_FN3_,
_FN4_,
_FN5_,
_FN6_,
_FN7_,
_FN49_,
_FN50_,
_FN61_,
_FN61_,
_FN8_,
_FN9_,
_FN10_,
_FN61_,
_FN61_,
_FN62_,
_FN61_,
_FN61_,
_FN61_,
_FN61_,
_FN61_,
_FN61_,
_FN51_,
_FN61_,
_FN11_,
_FN11_,
_FN11_,
_FN11_,
_FN61_,
_FN12_,
_FN12_,
_FN12_,
_FN12_,
_FN61_,
_FN13_,
_FN13_,
_FN13_,
_FN13_,
_FN52_,
_FN14_,
_FN14_,
_FN61_,
_FN62_,
_FN61_,
_FN61_,
_FN61_,
_FN61_,
_FN15_,
_FN15_,
_FN16_,
_FN17_,
_FN16_,
_FN17_,
_FN18_,
_FN18_,
_FN19_,
_FN19_,
_FN20_,
_FN21_,
_FN20_,
_FN21_,
_FN22_,
_FN22_,
_FN23_,
_FN23_,
_FN24_,
_FN24_,
_FN25_,
_FN26_,
_FN27_,
_FN28_,
_FN29_,
_FN30_,
_FN31_,
_FN32_,
_FN62_,
_FN62_,
_FN33_,
_FN33_,
_FN33_,
_FN34_,
_FN34_,
_FN34_,
_FN35_,
_FN31_,
_FN36_,
_FN32_,
_FN61_,
_FN61_,
_FN37_,
_FN38_,
_FN39_,
_FN40_,
_FN41_,
_FN41_,
_FN42_,
_FN43_,
_FN42_,
_FN43_,
_FN44_,
_FN44_,
_FN45_,
_FN45_,
_FN45_,
_FN45_,
_FN45_,
_FN45_,
_FN45_,
_FN45_,
_FN45_,
_FN45_,
_FN45_,
_FN45_,
_FN46_,
_FN61_,
_FN61_,
_FN52_,
_FN52_,
_FN53_,
_FN54_,
_FN61_,
_FN61_,
_FN61_,
_FN61_,
_FN62_,
_FN61_,
_FN61_,
_FN61_,
_FN52_,
_FN55_,
_FN50_,
_FN56_,
_FN57_,
_FN58_,
_FN59_,
_FN51_,
_FN51_,
_FN51_,
_FN51_,
_FN51_,
_FN51_,
_FN51_,
_FN51_,
_FN51_,
_FN51_,
_FN51_,
_FN51_,
_FN51_,
_FN56_,
_FN57_,
_FN56_,
_FN57_,
_FN47_,
_FN48_,
_FN60_,
_FN50_,
];
