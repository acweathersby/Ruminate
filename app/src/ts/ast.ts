
/* **** DO NOT MODIFY **** DO NOT MODIFY **** DO NOT MODIFY ****
 * 
 * This code has been automatically generated by Hydrocarbon Toolkit
 * 
 * ###################################################################
 * 
 * Copyright 2022 Anthony C. Weathersby
 * 
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 */


import {
    ASTNode,
    ByteReader,
    ByteWriter,
    Token,
    Deserialize as InternalDeserialize,
    SerializeType,
    SerializeVector,
    SerializeStructVector
} from "@hctoolkit/runtime";


export enum ASTType {
    Markdown = 22,
    Line = 24,
    CodeBlock = 26,
    Header = 28,
    BulletHeader = 30,
    Quote = 32,
    Paragraph = 34,
    Text = 36,
    Query = 38,
    MarkerA = 40,
    MarkerB = 42,
    MarkerC = 44
}



export function Deserialize(reader: ByteReader) {
    return InternalDeserialize(reader, DeserializeStruct);
}

function DeserializeStruct(reader: ByteReader): ASTNode<ASTType> {
    switch (reader.peek_byte()) {

        case 1: return Markdown.Deserialize(reader);
        case 1: return Line.Deserialize(reader);
        case 1: return CodeBlock.Deserialize(reader);
        case 1: return Header.Deserialize(reader);
        case 1: return BulletHeader.Deserialize(reader);
        case 1: return Quote.Deserialize(reader);
        case 1: return Paragraph.Deserialize(reader);
        case 1: return Text.Deserialize(reader);
        case 1: return Query.Deserialize(reader);
        case 1: return MarkerA.Deserialize(reader);
        case 1: return MarkerB.Deserialize(reader);
        case 1: return MarkerC.Deserialize(reader);
    }
    throw new Error("Could not deserialize");
}


export class Markdown extends ASTNode<ASTType> {

    lines: (Line | CodeBlock)[];

    constructor(
        _lines: (Line | CodeBlock)[],) {
        super();
        this.lines = _lines;

    }
    replace_lines(child: ASTNode<ASTType>, j: number): null | ASTNode<ASTType> {

        if (child === null) {
            if (j < this.lines.length && j >= 0) {
                return this.lines.splice(j, 1)[0];
            }
        } else if (Line.nodeIs(child)
            || CodeBlock.nodeIs(child)) {
            if (j < 0) {
                this.lines.unshift(child);
            } else if (j >= this.lines.length) {
                this.lines.push(child);
            } else {
                return this.lines.splice(j, 1, child)[0];
            }
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

        for (let i = 0; i < this.lines.length; i++) {
            this.lines[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        }
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null {

        switch (i) {
            case 0: return this.replace_lines(child, j);
        }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Markdown {
        if (typeof s == "object")
            return s instanceof Markdown;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Markdown {
        return s.type == ASTType.Markdown;
    }

    static Type(): ASTType.Markdown {
        return ASTType.Markdown;
    }

    get type(): ASTType.Markdown {
        return ASTType.Markdown;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

        SerializeStructVector(this.lines, writer);
    }

    static Deserialize(reader: ByteReader): Markdown {

        reader.assert_byte(1);


        var _lines = Deserialize(reader);

        return new Markdown(_lines);
    }
}



export class Line extends ASTNode<ASTType> {

    header: (Header | BulletHeader | Quote | Paragraph);
    content: (Text | MarkerA | MarkerB | MarkerC | Query)[];

    constructor(
        _header: (Header | BulletHeader | Quote | Paragraph),
        _content: (Text | MarkerA | MarkerB | MarkerC | Query)[],) {
        super();
        this.header = _header;
        this.content = _content;

    }
    replace_header(child: ASTNode<ASTType>): null | ASTNode<ASTType> {

        if (Header.nodeIs(child)
            || BulletHeader.nodeIs(child)
            || Quote.nodeIs(child)
            || Paragraph.nodeIs(child)) {

            let old = this.header;

            this.header = child;

            return old;
        }
        return null;
    }

    replace_content(child: ASTNode<ASTType>, j: number): null | ASTNode<ASTType> {

        if (child === null) {
            if (j < this.content.length && j >= 0) {
                return this.content.splice(j, 1)[0];
            }
        } else if (Text.nodeIs(child)
            || MarkerA.nodeIs(child)
            || MarkerB.nodeIs(child)
            || MarkerC.nodeIs(child)
            || Query.nodeIs(child)) {
            if (j < 0) {
                this.content.unshift(child);
            } else if (j >= this.content.length) {
                this.content.push(child);
            } else {
                return this.content.splice(j, 1, child)[0];
            }
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

        this.header.$$____Iterate_$_$_$(_yield, this, 0, 0);

        for (let i = 0; i < this.content.length; i++) {
            this.content[i].$$____Iterate_$_$_$(_yield, this, 1, i);
        }
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null {

        switch (i) {
            case 0: return this.replace_header(child);
            case 1: return this.replace_content(child, j);
        }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Line {
        if (typeof s == "object")
            return s instanceof Line;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Line {
        return s.type == ASTType.Line;
    }

    static Type(): ASTType.Line {
        return ASTType.Line;
    }

    get type(): ASTType.Line {
        return ASTType.Line;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

        this._header.serialize(writer);

        SerializeStructVector(this._content, writer);
    }

    static Deserialize(reader: ByteReader): Line {

        reader.assert_byte(1);


        var _header = Deserialize(reader);

        var _content = Deserialize(reader);

        return new Line(header, content);
    }
}



export class CodeBlock extends ASTNode<ASTType> {

    syntax: string;
    data: Text | null;

    constructor(
        _syntax: string,
        _data: Text | null,) {
        super();
        this.syntax = _syntax;
        this.data = _data;

    }
    replace_data(child: ASTNode<ASTType>): null | ASTNode<ASTType> {

        if (child === null) {
            let old = this.data;

            this.data = null;

            return old;
        }
        else
            if (Text.nodeIs(child)) {

                let old = this.data;

                this.data = child;

                return old;
            }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

        if (this.data instanceof ASTNode)
            this.data.$$____Iterate_$_$_$(_yield, this, 0, 0);
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null {

        switch (i) {
            case 0: return this.replace_data(child);
        }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is CodeBlock {
        if (typeof s == "object")
            return s instanceof CodeBlock;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is CodeBlock {
        return s.type == ASTType.CodeBlock;
    }

    static Type(): ASTType.CodeBlock {
        return ASTType.CodeBlock;
    }

    get type(): ASTType.CodeBlock {
        return ASTType.CodeBlock;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_string(this._syntax);

        if (!this._data)
            writer.write_null();
        else
            this._data.serialize(writer);

    }

    static Deserialize(reader: ByteReader): CodeBlock {

        reader.assert_byte(1);

        var _syntax = reader.read_string();

        var _data = reader.assert_null() ? null : Text.Deserialize(reader);

        return new CodeBlock(syntax, data);
    }
}



export class Header extends ASTNode<ASTType> {

    val: string;

    constructor(
        _val: string,) {
        super();
        this.val = _val;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Header {
        if (typeof s == "object")
            return s instanceof Header;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Header {
        return s.type == ASTType.Header;
    }

    static Type(): ASTType.Header {
        return ASTType.Header;
    }

    get type(): ASTType.Header {
        return ASTType.Header;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_string(this._val);
    }

    static Deserialize(reader: ByteReader): Header {

        reader.assert_byte(1);

        var _val = reader.read_string();

        return new Header(val);
    }
}



export class BulletHeader extends ASTNode<ASTType> {

    level: string;

    constructor(
        _level: string,) {
        super();
        this.level = _level;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is BulletHeader {
        if (typeof s == "object")
            return s instanceof BulletHeader;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is BulletHeader {
        return s.type == ASTType.BulletHeader;
    }

    static Type(): ASTType.BulletHeader {
        return ASTType.BulletHeader;
    }

    get type(): ASTType.BulletHeader {
        return ASTType.BulletHeader;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_string(this._level);
    }

    static Deserialize(reader: ByteReader): BulletHeader {

        reader.assert_byte(1);

        var _level = reader.read_string();

        return new BulletHeader(level);
    }
}



export class Quote extends ASTNode<ASTType> {

    level: string;

    constructor(
        _level: string,) {
        super();
        this.level = _level;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Quote {
        if (typeof s == "object")
            return s instanceof Quote;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Quote {
        return s.type == ASTType.Quote;
    }

    static Type(): ASTType.Quote {
        return ASTType.Quote;
    }

    get type(): ASTType.Quote {
        return ASTType.Quote;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_string(this._level);
    }

    static Deserialize(reader: ByteReader): Quote {

        reader.assert_byte(1);

        var _level = reader.read_string();

        return new Quote(level);
    }
}



export class Paragraph extends ASTNode<ASTType> {

    text: string;

    constructor(
        _text: string,) {
        super();
        this.text = _text;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Paragraph {
        if (typeof s == "object")
            return s instanceof Paragraph;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Paragraph {
        return s.type == ASTType.Paragraph;
    }

    static Type(): ASTType.Paragraph {
        return ASTType.Paragraph;
    }

    get type(): ASTType.Paragraph {
        return ASTType.Paragraph;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_string(this._text);
    }

    static Deserialize(reader: ByteReader): Paragraph {

        reader.assert_byte(1);

        var _text = reader.read_string();

        return new Paragraph(text);
    }
}



export class Text extends ASTNode<ASTType> {

    text: string;

    constructor(
        _text: string,) {
        super();
        this.text = _text;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Text {
        if (typeof s == "object")
            return s instanceof Text;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Text {
        return s.type == ASTType.Text;
    }

    static Type(): ASTType.Text {
        return ASTType.Text;
    }

    get type(): ASTType.Text {
        return ASTType.Text;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_string(this._text);
    }

    static Deserialize(reader: ByteReader): Text {

        reader.assert_byte(1);

        var _text = reader.read_string();

        return new Text(text);
    }
}



export class Query extends ASTNode<ASTType> {

    query: string;

    constructor(
        _query: string,) {
        super();
        this.query = _query;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Query {
        if (typeof s == "object")
            return s instanceof Query;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Query {
        return s.type == ASTType.Query;
    }

    static Type(): ASTType.Query {
        return ASTType.Query;
    }

    get type(): ASTType.Query {
        return ASTType.Query;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_string(this.query);
    }

    static Deserialize(reader: ByteReader): Query {

        reader.assert_byte(1);

        var _query = reader.read_string();

        return new Query(_query);
    }
}



export class MarkerA extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is MarkerA {
        if (typeof s == "object")
            return s instanceof MarkerA;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is MarkerA {
        return s.type == ASTType.MarkerA;
    }

    static Type(): ASTType.MarkerA {
        return ASTType.MarkerA;
    }

    get type(): ASTType.MarkerA {
        return ASTType.MarkerA;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): MarkerA {

        reader.assert_byte(1);



        return new MarkerA();
    }
}



export class MarkerB extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is MarkerB {
        if (typeof s == "object")
            return s instanceof MarkerB;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is MarkerB {
        return s.type == ASTType.MarkerB;
    }

    static Type(): ASTType.MarkerB {
        return ASTType.MarkerB;
    }

    get type(): ASTType.MarkerB {
        return ASTType.MarkerB;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): MarkerB {

        reader.assert_byte(1);



        return new MarkerB();
    }
}



export class MarkerC extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is MarkerC {
        if (typeof s == "object")
            return s instanceof MarkerC;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is MarkerC {
        return s.type == ASTType.MarkerC;
    }

    static Type(): ASTType.MarkerC {
        return ASTType.MarkerC;
    }

    get type(): ASTType.MarkerC {
        return ASTType.MarkerC;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): MarkerC {

        reader.assert_byte(1);



        return new MarkerC();
    }
}



/**
```
{ t_Markdown, lines:$1 }
```*/
function _FN0_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Markdown = new Markdown(
        v0,
    );;

    args.push(ref_0);
}
/**
```
{ t_Line, header:$1, content:$2 }
```*/
function _FN1_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: Line = new Line(
        v0,
        v1,
    );;

    args.push(ref_0);
}
/**
```
{ t_Line, header:$1, content:$NULL }
```*/
function _FN2_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Line = new Line(
        v0,
        [],
    );;

    args.push(ref_0);
}
/**
```
{ t_CodeBlock, syntax:str($2), data:$3 }
```*/
function _FN3_(args: any[], tok: Token): any {
    let v4 = args.pop();
    let v3 = args.pop();
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: CodeBlock = new CodeBlock(
        v1.toString(),
        v2,
    );;

    args.push(ref_0);
}
/**
```
{ t_CodeBlock, syntax:str($2), data:$NULL }
```*/
function _FN4_(args: any[], tok: Token): any {
    let v3 = args.pop();
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: CodeBlock = new CodeBlock(
        v1.toString(),
        null,
    );;

    args.push(ref_0);
}
/**
```
{ t_CodeBlock, syntax:str($2), data:$3 }
```*/
function _FN5_(args: any[], tok: Token): any {
    let v3 = args.pop();
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: CodeBlock = new CodeBlock(
        v1.toString(),
        v2,
    );;

    args.push(ref_0);
}
/**
```
{ t_CodeBlock, syntax:str($2), data:$NULL }
```*/
function _FN6_(args: any[], tok: Token): any {
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: CodeBlock = new CodeBlock(
        v1.toString(),
        null,
    );;

    args.push(ref_0);
}
/**
```
{ t_Header, val:str($2) }
```*/
function _FN7_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: Header = new Header(
        v1.toString(),
    );;

    args.push(ref_0);
}
/**
```
{ t_BulletHeader, level:str($2) }
```*/
function _FN8_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: BulletHeader = new BulletHeader(
        v1.toString(),
    );;

    args.push(ref_0);
}
/**
```
{ t_Quote, level:str($2) }
```*/
function _FN9_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: Quote = new Quote(
        v1.toString(),
    );;

    args.push(ref_0);
}
/**
```
{ t_Paragraph, text:str($2) }
```*/
function _FN10_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: Paragraph = new Paragraph(
        v1.toString(),
    );;

    args.push(ref_0);
}
/**
```
{ t_Paragraph, text:str("") }
```*/
function _FN11_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Paragraph = new Paragraph(
        "",
    );;

    args.push(ref_0);
}
/**
```
{ t_Text, text:str($2) }
```*/
function _FN12_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: Text = new Text(
        v1,
    );;

    args.push(ref_0);
}
/**
```
{ t_Text, text:str($NULL) }
```*/
function _FN13_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Text = new Text(
        "",
    );;

    args.push(ref_0);
}
/**
```
{ t_Query, query:str($2) }
```*/
function _FN14_(args: any[], tok: Token): any {
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: Query = new Query(
        v1,
    );;

    args.push(ref_0);
}
/**
```
{ t_Text, text:str($1) }
```*/
function _FN15_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Text = new Text(
        v0,
    );;

    args.push(ref_0);
}
/**
```
{ t_MarkerA }
```*/
function _FN16_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: MarkerA = new MarkerA(

    );;

    args.push(ref_0);
}
/**
```
{ t_MarkerB }
```*/
function _FN17_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: MarkerB = new MarkerB(

    );;

    args.push(ref_0);
}
/**
```
{ t_MarkerC }
```*/
function _FN18_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: MarkerC = new MarkerC(

    );;

    args.push(ref_0);
}
/**
```
str($1)
```*/
function _FN19_(args: any[], tok: Token): any {
    let v0 = args.pop();
    args.push(v0.toString());
}
/**
```
str($__first__)+str($__last__)
```*/
function _FN20_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();
    args.push(v0 + v1.toString());
}
/**
```
[$1]
```*/
function _FN21_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: (Text | MarkerA | MarkerB | MarkerC | Query)[] = [v0];

    args.push(ref_0);
}
/**
```
$__first__+$__last__
```*/
function _FN22_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    v0.push(v1);

    args.push(v0);
}
/**
```
[$1]
```*/
function _FN23_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: (Line | CodeBlock)[] = [v0];

    args.push(ref_0);
}
/**
```
[$1]
```*/
function _FN24_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: (Text)[] = [v0];

    args.push(ref_0);
}
/**
```
[$1]
```*/
function _FN25_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Token[] = [v0];

    args.push(ref_0);
}
/**
```
$__first__+$__last__
```*/
function _FN26_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    v0.push(v1);

    args.push(v0);
}
/**
```
[$2]
```*/
function _FN27_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: Token[] = [v1];

    args.push(ref_0);
}
/**
```
$__first__+$__last__
```*/
function _FN28_(args: any[], tok: Token): any {
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    v0.push(v2);

    args.push(v0);
}
/**
```
$1
```*/
function _FN29_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();


    args.push(v0);
}
/**
```

```*/
function _FN30_(args: any[], tok: Token): any { }



export const FunctionMaps = [
    _FN0_,
    _FN30_,
    _FN1_,
    _FN2_,
    _FN3_,
    _FN4_,
    _FN5_,
    _FN6_,
    _FN7_,
    _FN8_,
    _FN9_,
    _FN10_,
    _FN10_,
    _FN11_,
    _FN7_,
    _FN7_,
    _FN7_,
    _FN7_,
    _FN7_,
    _FN30_,
    _FN30_,
    _FN12_,
    _FN13_,
    _FN19_,
    _FN20_,
    _FN19_,
    _FN19_,
    _FN19_,
    _FN20_,
    _FN20_,
    _FN20_,
    _FN21_,
    _FN22_,
    _FN30_,
    _FN30_,
    _FN30_,
    _FN30_,
    _FN30_,
    _FN14_,
    _FN15_,
    _FN16_,
    _FN17_,
    _FN18_,
    _FN23_,
    _FN22_,
    _FN24_,
    _FN22_,
    _FN25_,
    _FN26_,
    _FN27_,
    _FN28_,
    _FN19_,
    _FN20_,
    _FN19_,
    _FN19_,
    _FN19_,
    _FN20_,
    _FN20_,
    _FN20_,
    _FN29_,
    _FN29_,
    _FN29_,
];
