
/* **** DO NOT MODIFY **** DO NOT MODIFY **** DO NOT MODIFY ****
 * 
 * This code has been automatically generated by Hydrocarbon Toolkit
 * 
 * ###################################################################
 * 
 * Copyright 2022 Anthony C. Weathersby
 * 
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 */


import {
    ASTNode,
    ByteReader,
    ByteWriter,
    Token,
    Deserialize as InternalDeserialize,
    SerializeType,
    SerializeVector,
    SerializeStructVector
} from "@hctoolkit/runtime";


export enum ASTType {
    Markdown = 22,
    Line = 24,
    Paragraph = 26,
    CodeBlock = 28,
    Text = 30,
    Header = 32,
    Ol = 34,
    Ul = 36,
    Quote = 38,
    InlineCode = 40,
    MarkerA = 42,
    MarkerB = 44,
    QueryStart = 46,
    QueryEnd = 48,
    AnchorStart = 50,
    AnchorImageStart = 52,
    AnchorEnd = 54,
    AnchorMiddle = 56
}



export function Deserialize(reader: ByteReader) {
    return InternalDeserialize(reader, DeserializeStruct);
}

function DeserializeStruct(reader: ByteReader): ASTNode<ASTType> {
    switch (reader.peek_byte()) {

        case 1: return Markdown.Deserialize(reader);
        case 1: return Line.Deserialize(reader);
        case 1: return Paragraph.Deserialize(reader);
        case 1: return CodeBlock.Deserialize(reader);
        case 1: return Text.Deserialize(reader);
        case 1: return Header.Deserialize(reader);
        case 1: return Ol.Deserialize(reader);
        case 1: return Ul.Deserialize(reader);
        case 1: return Quote.Deserialize(reader);
        case 1: return InlineCode.Deserialize(reader);
        case 1: return MarkerA.Deserialize(reader);
        case 1: return MarkerB.Deserialize(reader);
        case 1: return QueryStart.Deserialize(reader);
        case 1: return QueryEnd.Deserialize(reader);
        case 1: return AnchorStart.Deserialize(reader);
        case 1: return AnchorImageStart.Deserialize(reader);
        case 1: return AnchorEnd.Deserialize(reader);
        case 1: return AnchorMiddle.Deserialize(reader);
    }
    throw new Error("Could not deserialize");
}


export class Markdown extends ASTNode<ASTType> {

    lines: (CodeBlock | Line)[];
    tok: Token;

    constructor(
        _lines: (CodeBlock | Line)[],
        _tok: Token,) {
        super();
        this.lines = _lines;
        this.tok = _tok;

    }
    replace_lines(child: ASTNode<ASTType>, j: number): null | ASTNode<ASTType> {

        if (child === null) {
            if (j < this.lines.length && j >= 0) {
                return this.lines.splice(j, 1)[0];
            }
        } else if (CodeBlock.nodeIs(child)
            || Line.nodeIs(child)) {
            if (j < 0) {
                this.lines.unshift(child);
            } else if (j >= this.lines.length) {
                this.lines.push(child);
            } else {
                return this.lines.splice(j, 1, child)[0];
            }
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

        for (let i = 0; i < this.lines.length; i++) {
            this.lines[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        }
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null {

        switch (i) {
            case 0: return this.replace_lines(child, j);
        }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Markdown {
        if (typeof s == "object")
            return s instanceof Markdown;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Markdown {
        return s.type == ASTType.Markdown;
    }

    static Type(): ASTType.Markdown {
        return ASTType.Markdown;
    }

    get node_type(): ASTType.Markdown {
        return ASTType.Markdown;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

        SerializeStructVector(this.lines, writer);

        this.tok.serialize(writer);
    }

    static Deserialize(reader: ByteReader): Markdown {

        reader.assert_byte(1);


        var _lines = Deserialize(reader);

        var _tok = Token.Deserialize(reader);

        return new Markdown(_lines, _tok);
    }
}



export class Line extends ASTNode<ASTType> {

    header: (Header | Ol | Ul | Quote | Paragraph);
    content: (MarkerA | MarkerB | QueryStart | QueryEnd | AnchorStart | AnchorImageStart | AnchorEnd | AnchorMiddle | Text | InlineCode)[];
    tok: Token;

    constructor(
        _header: (Header | Ol | Ul | Quote | Paragraph),
        _content: (MarkerA | MarkerB | QueryStart | QueryEnd | AnchorStart | AnchorImageStart | AnchorEnd | AnchorMiddle | Text | InlineCode)[],
        _tok: Token,) {
        super();
        this.header = _header;
        this.content = _content;
        this.tok = _tok;

    }
    replace_header(child: ASTNode<ASTType>): null | ASTNode<ASTType> {

        if (Header.nodeIs(child)
            || Ol.nodeIs(child)
            || Ul.nodeIs(child)
            || Quote.nodeIs(child)
            || Paragraph.nodeIs(child)) {

            let old = this.header;

            this.header = child;

            return old;
        }
        return null;
    }

    replace_content(child: ASTNode<ASTType>, j: number): null | ASTNode<ASTType> {

        if (child === null) {
            if (j < this.content.length && j >= 0) {
                return this.content.splice(j, 1)[0];
            }
        } else if (MarkerA.nodeIs(child)
            || MarkerB.nodeIs(child)
            || QueryStart.nodeIs(child)
            || QueryEnd.nodeIs(child)
            || AnchorStart.nodeIs(child)
            || AnchorImageStart.nodeIs(child)
            || AnchorEnd.nodeIs(child)
            || AnchorMiddle.nodeIs(child)
            || Text.nodeIs(child)
            || InlineCode.nodeIs(child)) {
            if (j < 0) {
                this.content.unshift(child);
            } else if (j >= this.content.length) {
                this.content.push(child);
            } else {
                return this.content.splice(j, 1, child)[0];
            }
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

        this.header.$$____Iterate_$_$_$(_yield, this, 0, 0);

        for (let i = 0; i < this.content.length; i++) {
            this.content[i].$$____Iterate_$_$_$(_yield, this, 1, i);
        }
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null {

        switch (i) {
            case 0: return this.replace_header(child);
            case 1: return this.replace_content(child, j);
        }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Line {
        if (typeof s == "object")
            return s instanceof Line;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Line {
        return s.type == ASTType.Line;
    }

    static Type(): ASTType.Line {
        return ASTType.Line;
    }

    get node_type(): ASTType.Line {
        return ASTType.Line;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

        this.header.serialize(writer);

        SerializeStructVector(this.content, writer);

        this.tok.serialize(writer);
    }

    static Deserialize(reader: ByteReader): Line {

        reader.assert_byte(1);


        var _header = Deserialize(reader);

        var _content = Deserialize(reader);

        var _tok = Token.Deserialize(reader);

        return new Line(_header, _content, _tok);
    }
}



export class Paragraph extends ASTNode<ASTType> {

    text: string;

    constructor(
        _text: string,) {
        super();
        this.text = _text;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Paragraph {
        if (typeof s == "object")
            return s instanceof Paragraph;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Paragraph {
        return s.type == ASTType.Paragraph;
    }

    static Type(): ASTType.Paragraph {
        return ASTType.Paragraph;
    }

    get node_type(): ASTType.Paragraph {
        return ASTType.Paragraph;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_string(this.text);
    }

    static Deserialize(reader: ByteReader): Paragraph {

        reader.assert_byte(1);

        var _text = reader.read_string();

        return new Paragraph(_text);
    }
}



export class CodeBlock extends ASTNode<ASTType> {

    syntax: Text | null;
    data: Text[];

    constructor(
        _syntax: Text | null,
        _data: Text[],) {
        super();
        this.syntax = _syntax;
        this.data = _data;

    }
    replace_syntax(child: ASTNode<ASTType>): null | ASTNode<ASTType> {

        if (child === null) {
            let old = this.syntax;

            this.syntax = null;

            return old;
        }
        else
            if (Text.nodeIs(child)) {

                let old = this.syntax;

                this.syntax = child;

                return old;
            }
        return null;
    }

    replace_data(child: ASTNode<ASTType>, j: number): null | ASTNode<ASTType> {

        if (child === null) {
            if (j < this.data.length && j >= 0) {
                return this.data.splice(j, 1)[0];
            }
        } else if (Text.nodeIs(child)) {
            if (j < 0) {
                this.data.unshift(child);
            } else if (j >= this.data.length) {
                this.data.push(child);
            } else {
                return this.data.splice(j, 1, child)[0];
            }
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

        if (this.syntax instanceof ASTNode)
            this.syntax.$$____Iterate_$_$_$(_yield, this, 0, 0);

        for (let i = 0; i < this.data.length; i++) {
            this.data[i].$$____Iterate_$_$_$(_yield, this, 1, i);
        }
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null {

        switch (i) {
            case 0: return this.replace_syntax(child);
            case 1: return this.replace_data(child, j);
        }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is CodeBlock {
        if (typeof s == "object")
            return s instanceof CodeBlock;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is CodeBlock {
        return s.type == ASTType.CodeBlock;
    }

    static Type(): ASTType.CodeBlock {
        return ASTType.CodeBlock;
    }

    get node_type(): ASTType.CodeBlock {
        return ASTType.CodeBlock;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

        if (!this.syntax)
            writer.write_null();
        else
            this.syntax.serialize(writer);


        SerializeStructVector(this.data, writer);
    }

    static Deserialize(reader: ByteReader): CodeBlock {

        reader.assert_byte(1);


        var _syntax = reader.assert_null() ? null : Text.Deserialize(reader);

        var _data = Deserialize(reader);

        return new CodeBlock(_syntax, _data);
    }
}



export class Text extends ASTNode<ASTType> {

    value: string;

    constructor(
        _value: string,) {
        super();
        this.value = _value;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Text {
        if (typeof s == "object")
            return s instanceof Text;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Text {
        return s.type == ASTType.Text;
    }

    static Type(): ASTType.Text {
        return ASTType.Text;
    }

    get node_type(): ASTType.Text {
        return ASTType.Text;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_string(this.value);
    }

    static Deserialize(reader: ByteReader): Text {

        reader.assert_byte(1);

        var _value = reader.read_string();

        return new Text(_value);
    }
}



export class Header extends ASTNode<ASTType> {

    length: number;

    constructor(
        _length: number,) {
        super();
        this.length = _length;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Header {
        if (typeof s == "object")
            return s instanceof Header;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Header {
        return s.type == ASTType.Header;
    }

    static Type(): ASTType.Header {
        return ASTType.Header;
    }

    get node_type(): ASTType.Header {
        return ASTType.Header;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_double(this.length);
    }

    static Deserialize(reader: ByteReader): Header {

        reader.assert_byte(1);

        var _length = reader.read_double();

        return new Header(_length);
    }
}



export class Ol extends ASTNode<ASTType> {

    offset: number;

    constructor(
        _offset: number,) {
        super();
        this.offset = _offset;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Ol {
        if (typeof s == "object")
            return s instanceof Ol;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Ol {
        return s.type == ASTType.Ol;
    }

    static Type(): ASTType.Ol {
        return ASTType.Ol;
    }

    get node_type(): ASTType.Ol {
        return ASTType.Ol;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_double(this.offset);
    }

    static Deserialize(reader: ByteReader): Ol {

        reader.assert_byte(1);

        var _offset = reader.read_double();

        return new Ol(_offset);
    }
}



export class Ul extends ASTNode<ASTType> {

    offset: number;

    constructor(
        _offset: number,) {
        super();
        this.offset = _offset;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Ul {
        if (typeof s == "object")
            return s instanceof Ul;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Ul {
        return s.type == ASTType.Ul;
    }

    static Type(): ASTType.Ul {
        return ASTType.Ul;
    }

    get node_type(): ASTType.Ul {
        return ASTType.Ul;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_double(this.offset);
    }

    static Deserialize(reader: ByteReader): Ul {

        reader.assert_byte(1);

        var _offset = reader.read_double();

        return new Ul(_offset);
    }
}



export class Quote extends ASTNode<ASTType> {

    offset: number;

    constructor(
        _offset: number,) {
        super();
        this.offset = _offset;

    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is Quote {
        if (typeof s == "object")
            return s instanceof Quote;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is Quote {
        return s.type == ASTType.Quote;
    }

    static Type(): ASTType.Quote {
        return ASTType.Quote;
    }

    get node_type(): ASTType.Quote {
        return ASTType.Quote;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);
        writer.write_double(this.offset);
    }

    static Deserialize(reader: ByteReader): Quote {

        reader.assert_byte(1);

        var _offset = reader.read_double();

        return new Quote(_offset);
    }
}



export class InlineCode extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is InlineCode {
        if (typeof s == "object")
            return s instanceof InlineCode;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is InlineCode {
        return s.type == ASTType.InlineCode;
    }

    static Type(): ASTType.InlineCode {
        return ASTType.InlineCode;
    }

    get node_type(): ASTType.InlineCode {
        return ASTType.InlineCode;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): InlineCode {

        reader.assert_byte(1);



        return new InlineCode();
    }
}



export class MarkerA extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is MarkerA {
        if (typeof s == "object")
            return s instanceof MarkerA;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is MarkerA {
        return s.type == ASTType.MarkerA;
    }

    static Type(): ASTType.MarkerA {
        return ASTType.MarkerA;
    }

    get node_type(): ASTType.MarkerA {
        return ASTType.MarkerA;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): MarkerA {

        reader.assert_byte(1);



        return new MarkerA();
    }
}



export class MarkerB extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is MarkerB {
        if (typeof s == "object")
            return s instanceof MarkerB;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is MarkerB {
        return s.type == ASTType.MarkerB;
    }

    static Type(): ASTType.MarkerB {
        return ASTType.MarkerB;
    }

    get node_type(): ASTType.MarkerB {
        return ASTType.MarkerB;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): MarkerB {

        reader.assert_byte(1);



        return new MarkerB();
    }
}



export class QueryStart extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is QueryStart {
        if (typeof s == "object")
            return s instanceof QueryStart;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is QueryStart {
        return s.type == ASTType.QueryStart;
    }

    static Type(): ASTType.QueryStart {
        return ASTType.QueryStart;
    }

    get node_type(): ASTType.QueryStart {
        return ASTType.QueryStart;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): QueryStart {

        reader.assert_byte(1);



        return new QueryStart();
    }
}



export class QueryEnd extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is QueryEnd {
        if (typeof s == "object")
            return s instanceof QueryEnd;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is QueryEnd {
        return s.type == ASTType.QueryEnd;
    }

    static Type(): ASTType.QueryEnd {
        return ASTType.QueryEnd;
    }

    get node_type(): ASTType.QueryEnd {
        return ASTType.QueryEnd;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): QueryEnd {

        reader.assert_byte(1);



        return new QueryEnd();
    }
}



export class AnchorStart extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is AnchorStart {
        if (typeof s == "object")
            return s instanceof AnchorStart;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is AnchorStart {
        return s.type == ASTType.AnchorStart;
    }

    static Type(): ASTType.AnchorStart {
        return ASTType.AnchorStart;
    }

    get node_type(): ASTType.AnchorStart {
        return ASTType.AnchorStart;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): AnchorStart {

        reader.assert_byte(1);



        return new AnchorStart();
    }
}



export class AnchorImageStart extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is AnchorImageStart {
        if (typeof s == "object")
            return s instanceof AnchorImageStart;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is AnchorImageStart {
        return s.type == ASTType.AnchorImageStart;
    }

    static Type(): ASTType.AnchorImageStart {
        return ASTType.AnchorImageStart;
    }

    get node_type(): ASTType.AnchorImageStart {
        return ASTType.AnchorImageStart;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): AnchorImageStart {

        reader.assert_byte(1);



        return new AnchorImageStart();
    }
}



export class AnchorEnd extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is AnchorEnd {
        if (typeof s == "object")
            return s instanceof AnchorEnd;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is AnchorEnd {
        return s.type == ASTType.AnchorEnd;
    }

    static Type(): ASTType.AnchorEnd {
        return ASTType.AnchorEnd;
    }

    get node_type(): ASTType.AnchorEnd {
        return ASTType.AnchorEnd;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): AnchorEnd {

        reader.assert_byte(1);



        return new AnchorEnd();
    }
}



export class AnchorMiddle extends ASTNode<ASTType> {



    constructor() {
        super();


    }

    $$____Iterate_$_$_$(
        _yield: (a: ASTNode<ASTType>, b: ASTNode<ASTType>, c: number, d: number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return; };

    }

    Replace(child: ASTNode<ASTType>, i: number, j: number): ASTNode<ASTType> | null { return null; }


    /* Token(): Token{
        return this.tok;
    } */

    static is(s: any): s is AnchorMiddle {
        if (typeof s == "object")
            return s instanceof AnchorMiddle;
        return false;
    }

    static nodeIs(s: ASTNode<ASTType>): s is AnchorMiddle {
        return s.type == ASTType.AnchorMiddle;
    }

    static Type(): ASTType.AnchorMiddle {
        return ASTType.AnchorMiddle;
    }

    get node_type(): ASTType.AnchorMiddle {
        return ASTType.AnchorMiddle;
    }

    serialize(writer: ByteWriter) {

        writer.write_byte(1);

    }

    static Deserialize(reader: ByteReader): AnchorMiddle {

        reader.assert_byte(1);



        return new AnchorMiddle();
    }
}



/**
```
{ t_Markdown, lines:$1, tok }
```*/
function _FN0_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Markdown = new Markdown(
        v0,
        tok,
    );;

    args.push(ref_0);
}
/**
```
{ t_Line, header:$1, content:$2, tok }
```*/
function _FN1_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: Line = new Line(
        v0,
        v1,
        tok,
    );;

    args.push(ref_0);
}
/**
```
{ 

    t_Line,

    header:{ t_Paragraph, text:str("") },

    content:$1,

    tok
 }
```*/
function _FN2_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Paragraph = new Paragraph(
        "",
    );;
    let ref_1: Line = new Line(
        ref_0,
        v0,
        tok,
    );;

    args.push(ref_1);
}
/**
```
{ t_CodeBlock, syntax:$2, data:$3 }
```*/
function _FN3_(args: any[], tok: Token): any {
    let v3 = args.pop();
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: CodeBlock = new CodeBlock(
        v1,
        v2,
    );;

    args.push(ref_0);
}
/**
```
{ t_CodeBlock, syntax:$NULL, data:$2 }
```*/
function _FN4_(args: any[], tok: Token): any {
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: CodeBlock = new CodeBlock(
        null,
        v1,
    );;

    args.push(ref_0);
}
/**
```
{ t_CodeBlock, syntax:$2, data:$NULL }
```*/
function _FN5_(args: any[], tok: Token): any {
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: CodeBlock = new CodeBlock(
        v1,
        [],
    );;

    args.push(ref_0);
}
/**
```
{ t_CodeBlock, syntax:$NULL, data:$NULL }
```*/
function _FN6_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: CodeBlock = new CodeBlock(
        null,
        [],
    );;

    args.push(ref_0);
}
/**
```
{ t_Text, value:str($2) }
```*/
function _FN7_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: Text = new Text(
        v1,
    );;

    args.push(ref_0);
}
/**
```
{ t_Text, value:str($NULL) }
```*/
function _FN8_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Text = new Text(
        "",
    );;

    args.push(ref_0);
}
/**
```
{ t_Text, value:$1 }
```*/
function _FN9_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Text = new Text(
        v0,
    );;

    args.push(ref_0);
}
/**
```
{ t_Header, length:f64($1) }
```*/
function _FN10_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Header = new Header(
        v0.length,
    );;

    args.push(ref_0);
}
/**
```
{ t_Ol, offset:f64($1) }
```*/
function _FN11_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Ol = new Ol(
        v0.length,
    );;

    args.push(ref_0);
}
/**
```
{ t_Ul, offset:f64($1) }
```*/
function _FN12_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Ul = new Ul(
        v0.length,
    );;

    args.push(ref_0);
}
/**
```
{ t_Quote, offset:f64($1) }
```*/
function _FN13_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Quote = new Quote(
        v0.length,
    );;

    args.push(ref_0);
}
/**
```
{ t_InlineCode }
```*/
function _FN14_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: InlineCode = new InlineCode(

    );;

    args.push(ref_0);
}
/**
```
{ t_MarkerA }
```*/
function _FN15_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: MarkerA = new MarkerA(

    );;

    args.push(ref_0);
}
/**
```
{ t_MarkerB }
```*/
function _FN16_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: MarkerB = new MarkerB(

    );;

    args.push(ref_0);
}
/**
```
{ t_QueryStart }
```*/
function _FN17_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: QueryStart = new QueryStart(

    );;

    args.push(ref_0);
}
/**
```
{ t_QueryEnd }
```*/
function _FN18_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: QueryEnd = new QueryEnd(

    );;

    args.push(ref_0);
}
/**
```
{ t_AnchorStart }
```*/
function _FN19_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: AnchorStart = new AnchorStart(

    );;

    args.push(ref_0);
}
/**
```
{ t_AnchorImageStart }
```*/
function _FN20_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: AnchorImageStart = new AnchorImageStart(

    );;

    args.push(ref_0);
}
/**
```
{ t_AnchorEnd }
```*/
function _FN21_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: AnchorEnd = new AnchorEnd(

    );;

    args.push(ref_0);
}
/**
```
{ t_AnchorMiddle }
```*/
function _FN22_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: AnchorMiddle = new AnchorMiddle(

    );;

    args.push(ref_0);
}
/**
```
[$2]
```*/
function _FN23_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: (CodeBlock)[] = [v1];

    args.push(ref_0);
}
/**
```
$1+[$3]
```*/
function _FN24_(args: any[], tok: Token): any {
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: (CodeBlock | CodeBlock | Line)[] = [v2];
    ref_0.unshift(...v0);

    args.push(ref_0);
}
/**
```
$1+[{ 

    t_Line,

    header:{ t_Paragraph, text:str("") },

    content:null,

    tok
 }]
```*/
function _FN25_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: Paragraph = new Paragraph(
        "",
    );;
    let ref_1: Line = new Line(
        ref_0,
        [],
        tok,
    );;
    let ref_2: (Line | Line | CodeBlock)[] = [ref_1];
    ref_2.unshift(...v0);

    args.push(ref_2);
}
/**
```
[$2]
```*/
function _FN26_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: (Line)[] = [v1];

    args.push(ref_0);
}
/**
```
$1+[$3]
```*/
function _FN27_(args: any[], tok: Token): any {
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: (Line | Line | CodeBlock)[] = [v2];
    ref_0.unshift(...v0);

    args.push(ref_0);
}
/**
```
[$1]
```*/
function _FN28_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: (CodeBlock)[] = [v0];

    args.push(ref_0);
}
/**
```
[$1]
```*/
function _FN29_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: (Line)[] = [v0];

    args.push(ref_0);
}
/**
```
str($1)
```*/
function _FN30_(args: any[], tok: Token): any {
    let v0 = args.pop();
    args.push(v0.toString());
}
/**
```
str($__first__)+str($__last__)
```*/
function _FN31_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();
    args.push(v0 + v1.toString());
}
/**
```
[$1]
```*/
function _FN32_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: (MarkerA | MarkerB | QueryStart | QueryEnd | AnchorStart | AnchorImageStart | AnchorEnd | AnchorMiddle)[] = [v0];

    args.push(ref_0);
}
/**
```
$__first__+$__last__
```*/
function _FN33_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    v0.push(v1);

    args.push(v0);
}
/**
```
[$1]
```*/
function _FN34_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: (Text)[] = [v0];

    args.push(ref_0);
}
/**
```
[$1]
```*/
function _FN35_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: (InlineCode)[] = [v0];

    args.push(ref_0);
}
/**
```
[$1]
```*/
function _FN36_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: Token[] = [v0];

    args.push(ref_0);
}
/**
```
[$1]
```*/
function _FN37_(args: any[], tok: Token): any {
    let v2 = args.pop();
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: (string | number | boolean | Token)[][] = [...v0];

    args.push(ref_0);
}
/**
```
[$NULL]
```*/
function _FN38_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: null[] = [];

    args.push(ref_0);
}
/**
```
[$1]
```*/
function _FN39_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();

    let ref_0: (string | number | boolean | Token)[][] = [...v0];

    args.push(ref_0);
}
/**
```
[$NULL]
```*/
function _FN40_(args: any[], tok: Token): any {
    let v0 = args.pop();

    let ref_0: null[] = [];

    args.push(ref_0);
}
/**
```

```*/
function _FN41_(args: any[], tok: Token): any { }
/**
```

```*/
function _FN42_(args: any[], tok: Token): any {
    let v1 = args.pop();
    let v0 = args.pop();
    args.push(v1);
}



export const FunctionMaps = [
    _FN0_,
    _FN23_,
    _FN24_,
    _FN25_,
    _FN26_,
    _FN27_,
    _FN28_,
    _FN29_,
    _FN1_,
    _FN2_,
    _FN3_,
    _FN4_,
    _FN5_,
    _FN6_,
    _FN7_,
    _FN8_,
    _FN30_,
    _FN31_,
    _FN30_,
    _FN30_,
    _FN30_,
    _FN31_,
    _FN31_,
    _FN31_,
    _FN41_,
    _FN41_,
    _FN32_,
    _FN33_,
    _FN34_,
    _FN35_,
    _FN33_,
    _FN33_,
    _FN36_,
    _FN33_,
    _FN9_,
    _FN41_,
    _FN41_,
    _FN41_,
    _FN41_,
    _FN41_,
    _FN42_,
    _FN41_,
    _FN42_,
    _FN10_,
    _FN11_,
    _FN12_,
    _FN13_,
    _FN36_,
    _FN33_,
    _FN37_,
    _FN38_,
    _FN39_,
    _FN39_,
    _FN40_,
    _FN40_,
    _FN39_,
    _FN40_,
    _FN14_,
    _FN36_,
    _FN33_,
    _FN15_,
    _FN16_,
    _FN17_,
    _FN18_,
    _FN19_,
    _FN20_,
    _FN21_,
    _FN22_,
    _FN21_,
    _FN34_,
    _FN33_,
    _FN30_,
    _FN31_,
];
