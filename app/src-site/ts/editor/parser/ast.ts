
/* **** DO NOT MODIFY **** DO NOT MODIFY **** DO NOT MODIFY ****
 * 
 * This code has been automatically generated by Hydrocarbon Toolkit
 * 
 * ###################################################################
 * 
 * Copyright 2022 Anthony C. Weathersby
 * 
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 */


import {
    ASTNode,
    ByteReader,
    ByteWriter,
    Token,
    Deserialize as InternalDeserialize,
    SerializeType,
    SerializeVector,
    SerializeStructVector
} from "@hctoolkit/runtime";

export type c_Line = Header
   | OL
   | UL
   | Quote
   | Paragraph
   | CodeBlock
   | EmptyLine;


export function isLine(s:ASTNode<ASTType>): s is c_Line{
    return (s.type & 2) ==  2;
}
        

export type c_Content = Text
   | InlineCode
   | MarkerA
   | MarkerB
   | QueryStart
   | QueryEnd
   | AnchorStart
   | AnchorImageStart
   | AnchorEnd
   | AnchorMiddle
   | MetaStart;


export function isContent(s:ASTNode<ASTType>): s is c_Content{
    return (s.type & 4) ==  4;
}
        

export type c_Meta = AnchorEnd
   | MetaStart;


export function isMeta(s:ASTNode<ASTType>): s is c_Meta{
    return (s.type & 8) ==  8;
}
        


export enum ASTClass {
Line = 2,
Content = 4,
Meta = 8
}



export enum ASTType {
Markdown = 176,
Header = 194,
OL = 210,
UL = 226,
Quote = 242,
Paragraph = 258,
CodeBlock = 274,
Text = 292,
InlineCode = 308,
MarkerA = 324,
MarkerB = 340,
QueryStart = 356,
QueryEnd = 372,
AnchorStart = 388,
AnchorImageStart = 404,
AnchorEnd = 428,
AnchorMiddle = 436,
MetaStart = 460,
EmptyLine = 466
}



export function Deserialize(reader: ByteReader){
    return InternalDeserialize(reader, DeserializeStruct)
}

function DeserializeStruct(reader: ByteReader): ASTNode<ASTType>{
    switch(reader.peek_byte()){
        
        case 0: return Markdown.Deserialize(reader);
        case 0: return Header.Deserialize(reader);
        case 0: return OL.Deserialize(reader);
        case 0: return UL.Deserialize(reader);
        case 0: return Quote.Deserialize(reader);
        case 0: return Paragraph.Deserialize(reader);
        case 0: return CodeBlock.Deserialize(reader);
        case 0: return Text.Deserialize(reader);
        case 0: return InlineCode.Deserialize(reader);
        case 0: return MarkerA.Deserialize(reader);
        case 0: return MarkerB.Deserialize(reader);
        case 0: return QueryStart.Deserialize(reader);
        case 0: return QueryEnd.Deserialize(reader);
        case 0: return AnchorStart.Deserialize(reader);
        case 0: return AnchorImageStart.Deserialize(reader);
        case 0: return AnchorEnd.Deserialize(reader);
        case 0: return AnchorMiddle.Deserialize(reader);
        case 0: return MetaStart.Deserialize(reader);
        case 0: return EmptyLine.Deserialize(reader);
    }
    throw new Error("Could not deserialize");
}


export class Markdown extends ASTNode<ASTType> {
    
    lines:c_Line[];

    constructor(
        _lines:c_Line[],) 
    {
        super();
            this.lines = _lines;
        
    }
    replace_lines(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.lines.length && j >= 0){
                return this.lines.splice(j, 1)[0];
            }
        }else if(isLine(child)){
            if(j < 0){
                this.lines.unshift(child);
            }else if(j >= this.lines.length){
                this.lines.push(child);
            }else {
                return this.lines.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.lines.length; i++){
            this.lines[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_lines(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Markdown {
        if(typeof s == "object")
            return s instanceof Markdown;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Markdown {
        return s.type == ASTType.Markdown;
    }

    static Type(): ASTType.Markdown {
        return ASTType.Markdown;
    }

    get type(): ASTType.Markdown {
        return ASTType.Markdown;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
        SerializeStructVector(this.lines, writer)
    }

    static Deserialize(reader:ByteReader): Markdown {

        reader.assert_byte(0);

        
        var _lines = Deserialize(reader);

        return new Markdown(_lines);
    }
}



export class Header extends ASTNode<ASTType> {
    
    length:number;
content:c_Content[];

    constructor(
        _length:number,
        _content:c_Content[],) 
    {
        super();
            this.length = _length;
        this.content = _content;
        
    }
    replace_content(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.content.length && j >= 0){
                return this.content.splice(j, 1)[0];
            }
        }else if(isContent(child)){
            if(j < 0){
                this.content.unshift(child);
            }else if(j >= this.content.length){
                this.content.push(child);
            }else {
                return this.content.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.content.length; i++){
            this.content[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_content(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Header {
        if(typeof s == "object")
            return s instanceof Header;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Header {
        return s.type == ASTType.Header;
    }

    static Type(): ASTType.Header {
        return ASTType.Header;
    }

    get type(): ASTType.Header {
        return ASTType.Header;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                    writer.write_double(this.length)

        SerializeStructVector(this.content, writer)
    }

    static Deserialize(reader:ByteReader): Header {

        reader.assert_byte(0);

                    var _length = reader.read_double()

        var _content = Deserialize(reader);

        return new Header(_length, _content);
    }
}



export class OL extends ASTNode<ASTType> {
    
    spaces:string;
content:c_Content[];

    constructor(
        _spaces:string,
        _content:c_Content[],) 
    {
        super();
            this.spaces = _spaces;
        this.content = _content;
        
    }
    replace_content(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.content.length && j >= 0){
                return this.content.splice(j, 1)[0];
            }
        }else if(isContent(child)){
            if(j < 0){
                this.content.unshift(child);
            }else if(j >= this.content.length){
                this.content.push(child);
            }else {
                return this.content.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.content.length; i++){
            this.content[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_content(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is OL {
        if(typeof s == "object")
            return s instanceof OL;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is OL {
        return s.type == ASTType.OL;
    }

    static Type(): ASTType.OL {
        return ASTType.OL;
    }

    get type(): ASTType.OL {
        return ASTType.OL;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.spaces)

        SerializeStructVector(this.content, writer)
    }

    static Deserialize(reader:ByteReader): OL {

        reader.assert_byte(0);

                 var _spaces = reader.read_string()

        var _content = Deserialize(reader);

        return new OL(_spaces, _content);
    }
}



export class UL extends ASTNode<ASTType> {
    
    spaces:string;
content:c_Content[];

    constructor(
        _spaces:string,
        _content:c_Content[],) 
    {
        super();
            this.spaces = _spaces;
        this.content = _content;
        
    }
    replace_content(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.content.length && j >= 0){
                return this.content.splice(j, 1)[0];
            }
        }else if(isContent(child)){
            if(j < 0){
                this.content.unshift(child);
            }else if(j >= this.content.length){
                this.content.push(child);
            }else {
                return this.content.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.content.length; i++){
            this.content[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_content(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is UL {
        if(typeof s == "object")
            return s instanceof UL;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is UL {
        return s.type == ASTType.UL;
    }

    static Type(): ASTType.UL {
        return ASTType.UL;
    }

    get type(): ASTType.UL {
        return ASTType.UL;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.spaces)

        SerializeStructVector(this.content, writer)
    }

    static Deserialize(reader:ByteReader): UL {

        reader.assert_byte(0);

                 var _spaces = reader.read_string()

        var _content = Deserialize(reader);

        return new UL(_spaces, _content);
    }
}



export class Quote extends ASTNode<ASTType> {
    
    spaces:string;
content:c_Content[];

    constructor(
        _spaces:string,
        _content:c_Content[],) 
    {
        super();
            this.spaces = _spaces;
        this.content = _content;
        
    }
    replace_content(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.content.length && j >= 0){
                return this.content.splice(j, 1)[0];
            }
        }else if(isContent(child)){
            if(j < 0){
                this.content.unshift(child);
            }else if(j >= this.content.length){
                this.content.push(child);
            }else {
                return this.content.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.content.length; i++){
            this.content[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_content(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Quote {
        if(typeof s == "object")
            return s instanceof Quote;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Quote {
        return s.type == ASTType.Quote;
    }

    static Type(): ASTType.Quote {
        return ASTType.Quote;
    }

    get type(): ASTType.Quote {
        return ASTType.Quote;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.spaces)

        SerializeStructVector(this.content, writer)
    }

    static Deserialize(reader:ByteReader): Quote {

        reader.assert_byte(0);

                 var _spaces = reader.read_string()

        var _content = Deserialize(reader);

        return new Quote(_spaces, _content);
    }
}



export class Paragraph extends ASTNode<ASTType> {
    
    spaces:string;
content:c_Content[];

    constructor(
        _spaces:string,
        _content:c_Content[],) 
    {
        super();
            this.spaces = _spaces;
        this.content = _content;
        
    }
    replace_content(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.content.length && j >= 0){
                return this.content.splice(j, 1)[0];
            }
        }else if(isContent(child)){
            if(j < 0){
                this.content.unshift(child);
            }else if(j >= this.content.length){
                this.content.push(child);
            }else {
                return this.content.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.content.length; i++){
            this.content[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_content(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Paragraph {
        if(typeof s == "object")
            return s instanceof Paragraph;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Paragraph {
        return s.type == ASTType.Paragraph;
    }

    static Type(): ASTType.Paragraph {
        return ASTType.Paragraph;
    }

    get type(): ASTType.Paragraph {
        return ASTType.Paragraph;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.spaces)

        SerializeStructVector(this.content, writer)
    }

    static Deserialize(reader:ByteReader): Paragraph {

        reader.assert_byte(0);

                 var _spaces = reader.read_string()

        var _content = Deserialize(reader);

        return new Paragraph(_spaces, _content);
    }
}



export class CodeBlock extends ASTNode<ASTType> {
    
    syntax:string;
data:Text[];

    constructor(
        _syntax:string,
        _data:Text[],) 
    {
        super();
            this.syntax = _syntax;
        this.data = _data;
        
    }
    replace_data(child: ASTNode<ASTType>,j:number) : null | ASTNode<ASTType> {
        
        if(child === null){
            if(j < this.data.length && j >= 0){
                return this.data.splice(j, 1)[0];
            }
        }else if(Text.nodeIs(child)){
            if(j < 0){
                this.data.unshift(child);
            }else if(j >= this.data.length){
                this.data.push(child);
            }else {
                return this.data.splice(j, 1, child)[0];
            } 
        }
        return null;
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
        for(let i = 0; i < this.data.length; i++){
            this.data[i].$$____Iterate_$_$_$(_yield, this, 0, i);
        } 
    }
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {

        switch(i){
            case 0: return this.replace_data(child, j);
    }
        return null;
    }

    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is CodeBlock {
        if(typeof s == "object")
            return s instanceof CodeBlock;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is CodeBlock {
        return s.type == ASTType.CodeBlock;
    }

    static Type(): ASTType.CodeBlock {
        return ASTType.CodeBlock;
    }

    get type(): ASTType.CodeBlock {
        return ASTType.CodeBlock;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.syntax)

        SerializeStructVector(this.data, writer)
    }

    static Deserialize(reader:ByteReader): CodeBlock {

        reader.assert_byte(0);

                 var _syntax = reader.read_string()

        var _data = Deserialize(reader);

        return new CodeBlock(_syntax, _data);
    }
}



export class Text extends ASTNode<ASTType> {
    
    value:string;

    constructor(
        _value:string,) 
    {
        super();
            this.value = _value;
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is Text {
        if(typeof s == "object")
            return s instanceof Text;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is Text {
        return s.type == ASTType.Text;
    }

    static Type(): ASTType.Text {
        return ASTType.Text;
    }

    get type(): ASTType.Text {
        return ASTType.Text;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
                 writer.write_string(this.value)
    }

    static Deserialize(reader:ByteReader): Text {

        reader.assert_byte(0);

                 var _value = reader.read_string()

        return new Text(_value);
    }
}



export class InlineCode extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is InlineCode {
        if(typeof s == "object")
            return s instanceof InlineCode;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is InlineCode {
        return s.type == ASTType.InlineCode;
    }

    static Type(): ASTType.InlineCode {
        return ASTType.InlineCode;
    }

    get type(): ASTType.InlineCode {
        return ASTType.InlineCode;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): InlineCode {

        reader.assert_byte(0);

        

        return new InlineCode();
    }
}



export class MarkerA extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is MarkerA {
        if(typeof s == "object")
            return s instanceof MarkerA;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is MarkerA {
        return s.type == ASTType.MarkerA;
    }

    static Type(): ASTType.MarkerA {
        return ASTType.MarkerA;
    }

    get type(): ASTType.MarkerA {
        return ASTType.MarkerA;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): MarkerA {

        reader.assert_byte(0);

        

        return new MarkerA();
    }
}



export class MarkerB extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is MarkerB {
        if(typeof s == "object")
            return s instanceof MarkerB;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is MarkerB {
        return s.type == ASTType.MarkerB;
    }

    static Type(): ASTType.MarkerB {
        return ASTType.MarkerB;
    }

    get type(): ASTType.MarkerB {
        return ASTType.MarkerB;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): MarkerB {

        reader.assert_byte(0);

        

        return new MarkerB();
    }
}



export class QueryStart extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is QueryStart {
        if(typeof s == "object")
            return s instanceof QueryStart;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is QueryStart {
        return s.type == ASTType.QueryStart;
    }

    static Type(): ASTType.QueryStart {
        return ASTType.QueryStart;
    }

    get type(): ASTType.QueryStart {
        return ASTType.QueryStart;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): QueryStart {

        reader.assert_byte(0);

        

        return new QueryStart();
    }
}



export class QueryEnd extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is QueryEnd {
        if(typeof s == "object")
            return s instanceof QueryEnd;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is QueryEnd {
        return s.type == ASTType.QueryEnd;
    }

    static Type(): ASTType.QueryEnd {
        return ASTType.QueryEnd;
    }

    get type(): ASTType.QueryEnd {
        return ASTType.QueryEnd;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): QueryEnd {

        reader.assert_byte(0);

        

        return new QueryEnd();
    }
}



export class AnchorStart extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is AnchorStart {
        if(typeof s == "object")
            return s instanceof AnchorStart;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is AnchorStart {
        return s.type == ASTType.AnchorStart;
    }

    static Type(): ASTType.AnchorStart {
        return ASTType.AnchorStart;
    }

    get type(): ASTType.AnchorStart {
        return ASTType.AnchorStart;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): AnchorStart {

        reader.assert_byte(0);

        

        return new AnchorStart();
    }
}



export class AnchorImageStart extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is AnchorImageStart {
        if(typeof s == "object")
            return s instanceof AnchorImageStart;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is AnchorImageStart {
        return s.type == ASTType.AnchorImageStart;
    }

    static Type(): ASTType.AnchorImageStart {
        return ASTType.AnchorImageStart;
    }

    get type(): ASTType.AnchorImageStart {
        return ASTType.AnchorImageStart;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): AnchorImageStart {

        reader.assert_byte(0);

        

        return new AnchorImageStart();
    }
}



export class AnchorEnd extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is AnchorEnd {
        if(typeof s == "object")
            return s instanceof AnchorEnd;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is AnchorEnd {
        return s.type == ASTType.AnchorEnd;
    }

    static Type(): ASTType.AnchorEnd {
        return ASTType.AnchorEnd;
    }

    get type(): ASTType.AnchorEnd {
        return ASTType.AnchorEnd;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): AnchorEnd {

        reader.assert_byte(0);

        

        return new AnchorEnd();
    }
}



export class AnchorMiddle extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is AnchorMiddle {
        if(typeof s == "object")
            return s instanceof AnchorMiddle;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is AnchorMiddle {
        return s.type == ASTType.AnchorMiddle;
    }

    static Type(): ASTType.AnchorMiddle {
        return ASTType.AnchorMiddle;
    }

    get type(): ASTType.AnchorMiddle {
        return ASTType.AnchorMiddle;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): AnchorMiddle {

        reader.assert_byte(0);

        

        return new AnchorMiddle();
    }
}



export class MetaStart extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is MetaStart {
        if(typeof s == "object")
            return s instanceof MetaStart;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is MetaStart {
        return s.type == ASTType.MetaStart;
    }

    static Type(): ASTType.MetaStart {
        return ASTType.MetaStart;
    }

    get type(): ASTType.MetaStart {
        return ASTType.MetaStart;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): MetaStart {

        reader.assert_byte(0);

        

        return new MetaStart();
    }
}



export class EmptyLine extends ASTNode<ASTType> {
    
    

    constructor() 
    {
        super();
            
        
    }

    $$____Iterate_$_$_$(
        _yield: (a:ASTNode<ASTType>, b:ASTNode<ASTType>, c:number, d:number) => boolean,
        parent: ASTNode<ASTType>,
        i: number,
        j: number,
    ) {
        if (!_yield(this, parent, i, j)) { return };
    
    }
    
    Replace(child: ASTNode<ASTType>, i: number, j: number) : ASTNode<ASTType> | null {return null;}


    /* Token(): Token{
        return this.tok;
    } */

    static is(s:any ): s is EmptyLine {
        if(typeof s == "object")
            return s instanceof EmptyLine;
        return false;
    }

    static nodeIs(s:ASTNode<ASTType> ): s is EmptyLine {
        return s.type == ASTType.EmptyLine;
    }

    static Type(): ASTType.EmptyLine {
        return ASTType.EmptyLine;
    }

    get type(): ASTType.EmptyLine {
        return ASTType.EmptyLine;
    }

    serialize(writer:ByteWriter){

        writer.write_byte(0);
        
    }

    static Deserialize(reader:ByteReader): EmptyLine {

        reader.assert_byte(0);

        

        return new EmptyLine();
    }
}



/**
```
{ t_Markdown, lines:$1 }
```*/
function _FN0_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Markdown = new Markdown(
        v0,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Header, c_Line, length:f64($1), content:$2 }
```*/
function _FN1_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Header = new Header(
        v0.length,
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_OL, c_Line, spaces:str($1), content:$3 }
```*/
function _FN2_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:OL = new OL(
        v0.toString(),
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_UL, c_Line, spaces:str($1), content:$3 }
```*/
function _FN3_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:UL = new UL(
        v0.toString(),
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Quote, c_Line, spaces:str($1), content:$3 }
```*/
function _FN4_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Quote = new Quote(
        v0.toString(),
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Paragraph, c_Line, spaces:str($1), content:$2 }
```*/
function _FN5_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Paragraph = new Paragraph(
        v0.toString(),
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_CodeBlock, c_Line, syntax:str($2), data:$3 }
```*/
function _FN6_ (args: any[], tok: Token) : any { 
                        let v3 = args.pop();
let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:CodeBlock = new CodeBlock(
        v1,
        v2,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_OL, c_Line, spaces:str($NULL), content:$2 }
```*/
function _FN7_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:OL = new OL(
        "",
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_UL, c_Line, spaces:str($NULL), content:$2 }
```*/
function _FN8_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:UL = new UL(
        "",
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Quote, c_Line, spaces:str($NULL), content:$2 }
```*/
function _FN9_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Quote = new Quote(
        "",
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Paragraph, c_Line, spaces:str($NULL), content:$1 }
```*/
function _FN10_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Paragraph = new Paragraph(
        "",
        v0,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_CodeBlock, c_Line, syntax:str($NULL), data:$2 }
```*/
function _FN11_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:CodeBlock = new CodeBlock(
        "",
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_CodeBlock, c_Line, syntax:str($2), data:$NULL }
```*/
function _FN12_ (args: any[], tok: Token) : any { 
                        let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:CodeBlock = new CodeBlock(
        v1,
        [],
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_CodeBlock, c_Line, syntax:str($NULL), data:$NULL }
```*/
function _FN13_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:CodeBlock = new CodeBlock(
        "",
        [],
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Text, c_Content, value:str($2) }
```*/
function _FN14_ (args: any[], tok: Token) : any { 
                        let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:Text = new Text(
        v1,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Text, c_Content, value:str($NULL) }
```*/
function _FN15_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Text = new Text(
        "",
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_Text, c_Content, value:$1 }
```*/
function _FN16_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:Text = new Text(
        v0,
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_InlineCode, c_Content }
```*/
function _FN17_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:InlineCode = new InlineCode(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_MarkerA, c_Content }
```*/
function _FN18_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:MarkerA = new MarkerA(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_MarkerB, c_Content }
```*/
function _FN19_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:MarkerB = new MarkerB(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_QueryStart, c_Content }
```*/
function _FN20_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:QueryStart = new QueryStart(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_QueryEnd, c_Content }
```*/
function _FN21_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:QueryEnd = new QueryEnd(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_AnchorStart, c_Content }
```*/
function _FN22_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:AnchorStart = new AnchorStart(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_AnchorImageStart, c_Content }
```*/
function _FN23_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:AnchorImageStart = new AnchorImageStart(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_AnchorEnd, c_Content }
```*/
function _FN24_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:AnchorEnd = new AnchorEnd(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_AnchorMiddle, c_Content }
```*/
function _FN25_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:AnchorMiddle = new AnchorMiddle(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
{ t_MetaStart, c_Content, c_Meta }
```*/
function _FN26_ (args: any[], tok: Token) : any { 
                        let v0 = args.pop();
                                
 let ref_0:MetaStart = new MetaStart(
        
   );;

                                args.push(ref_0) 
                            }
/**
```
[$2]
```*/
function _FN27_ (args: any[], tok: Token) : any { 
                                let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:(Header | OL | UL | Quote | Paragraph | CodeBlock)[] = [v1];
 
                                args.push(ref_0) } 
/**
```
$1+[$3]
```*/
function _FN28_ (args: any[], tok: Token) : any { 
                                let v2 = args.pop();
let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:(Header | OL | UL | Quote | Paragraph | CodeBlock | Header | OL | UL | Quote | Paragraph | CodeBlock | EmptyLine)[] = [v2];
ref_0.unshift(...v0);
 
                                args.push(ref_0) } 
/**
```
$1+[{ t_EmptyLine, c_Line }]
```*/
function _FN29_ (args: any[], tok: Token) : any { 
                                let v1 = args.pop();
let v0 = args.pop();
                                
 let ref_0:EmptyLine = new EmptyLine(
        
   );;
 let ref_1:(EmptyLine | EmptyLine | Header | OL | UL | Quote | Paragraph | CodeBlock)[] = [ref_0];
ref_1.unshift(...v0);
 
                                args.push(ref_1) } 
/**
```
[$1]
```*/
function _FN30_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Header | OL | UL | Quote | Paragraph | CodeBlock)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
[$1]
```*/
function _FN31_ (args: any[], tok: Token) : any {
                            let v0 = args.pop(); 
                                
 let ref_0:Token[] = [v0];

                                args.push(ref_0) 
                            }
/**
```
$__first__+$__last__
```*/
function _FN32_ (args: any[], tok: Token) : any {
                            let v1 = args.pop();
let v0 = args.pop(); 
                                
v0.push(v1);

                                args.push(v0) 
                            }
/**
```
str($1)
```*/
function _FN33_ (args: any[], tok: Token) : any { let v0 = args.pop(); 
 args.push(v0.toString())}
/**
```
str($__first__)+str($__last__)
```*/
function _FN34_ (args: any[], tok: Token) : any { let v1 = args.pop();
let v0 = args.pop(); 
 args.push(v0 + v1.toString())}
/**
```
[$1]
```*/
function _FN35_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(InlineCode | MarkerA | MarkerB | QueryStart | QueryEnd | AnchorStart | AnchorImageStart | AnchorEnd | AnchorMiddle | MetaStart)[] = [v0];
 
                                args.push(ref_0) } 
/**
```
[$1]
```*/
function _FN36_ (args: any[], tok: Token) : any { 
                                let v0 = args.pop();
                                
 let ref_0:(Text)[] = [v0];
 
                                args.push(ref_0) } 
/**
```

```*/
function _FN37_ (args: any[], tok: Token) : any {  let v1 = args.pop();
let v0 = args.pop();
 args.push(v1); }
/**
```

```*/
function _FN38_ (args: any[], tok: Token) : any {}



export  const FunctionMaps = [
    _FN0_,
_FN27_,
_FN28_,
_FN29_,
_FN30_,
_FN1_,
_FN2_,
_FN3_,
_FN4_,
_FN5_,
_FN6_,
_FN7_,
_FN8_,
_FN9_,
_FN10_,
_FN11_,
_FN12_,
_FN13_,
_FN31_,
_FN32_,
_FN31_,
_FN32_,
_FN37_,
_FN38_,
_FN38_,
_FN38_,
_FN14_,
_FN15_,
_FN38_,
_FN37_,
_FN38_,
_FN38_,
_FN33_,
_FN34_,
_FN33_,
_FN33_,
_FN33_,
_FN34_,
_FN34_,
_FN34_,
_FN37_,
_FN35_,
_FN32_,
_FN36_,
_FN32_,
_FN16_,
_FN38_,
_FN38_,
_FN38_,
_FN38_,
_FN38_,
_FN37_,
_FN38_,
_FN37_,
_FN17_,
_FN18_,
_FN19_,
_FN20_,
_FN21_,
_FN22_,
_FN23_,
_FN24_,
_FN25_,
_FN24_,
_FN26_,
_FN36_,
_FN32_,
_FN33_,
_FN34_,
];
